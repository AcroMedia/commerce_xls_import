<?php
/**
 * @file
 * Imports Drupal Commerce Entities from an XLS file.
 *
 * Returns an XLS file highlighting success and failures.
 */

use Box\Spout\Common\Type;
use Box\Spout\Reader\ReaderFactory;
use Box\Spout\Writer\WriterFactory;
use Box\Spout\Writer\Style\StyleBuilder;
use Box\Spout\Writer\Style\Color;

define('COMMERCE_XLS_IMPORT_DATA_ERROR', 0);
define('COMMERCE_XLS_IMPORT_DATA_SUCCESS', 1);

/**
 * Implements hook_menu().
 *
 * Adds menu items to generate the headers or begin the commerce XLS import.
 */
function commerce_xls_import_menu() {
  $items = array();

  $items['admin/commerce/products/import_commerce'] = array(
    'title' => 'Commerce Import',
    'description' => 'Import commerce XLS or generate XLS headers form',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_xls_import_start'),
    'access arguments' => array('administer commerce import'),
    'file' => 'includes/commerce_xls_import.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );

  $items['admin/commerce/products/import_commerce/aliases'] = array(
    'title' => 'Configure Commerce Import Aliases',
    'description' => 'Configure aliases for fields',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_xls_import_aliases_form'),
    'access arguments' => array('administer commerce import'),
    'file' => 'includes/commerce_xls_import.admin.inc',
    'type' => MENU_LOCAL_ACTION,
  );

  $items['admin/commerce/products/export_commerce'] = array(
    'title' => 'Commerce Export',
    'description' => 'Export products to XLS.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_xls_import_start_export'),
    'access arguments' => array('administer commerce import'),
    'file' => 'includes/commerce_xls_import.export.inc',
    'type' => MENU_LOCAL_TASK,
  );

  $items['admin/commerce/products/import_commerce/get_import_status'] = array(
    'title' => 'Commerce Import Status Update',
    'description' => 'Update the status of the current commerce xls import',
    'page callback' => 'commerce_xls_import_current_status',
    'access arguments' => array('administer commerce import'),
    'file' => NULL,
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function commerce_xls_import_permission() {
  return array(
    'administer commerce import' => array(
      'title' => t('Administer Commerce XLS Import'),
      'description' => t('Perform an XLS import'),
    ),
  );
}

/**
 * Implements hook_theme().
 */
function commerce_xls_import_theme() {
  return array(
    'commerce_xls_import_instructions' => array(
      'file' => 'includes/commerce_xls_import.theme.inc',
      'template' => 'templates/commerce_xls_import_instructions',
      'variables' => array(),
    ),
  );
}

/**
 * Implements hook_libraries_info().
 */
function commerce_xls_import_libraries_info() {
  $libs = array();

  $libs['spout'] = array(
    'name' => 'spout',
    'vendor url' => 'https://packagist.org/packages/box/spout',
    'download url' => 'https://github.com/box/spout/releases',
    'version callback' => 'commerce_xls_import_spout_version',
    'files' => array(
      'php' => array(
        'src/Spout/Autoloader/autoload.php',
      ),
    ),
  );

  return $libs;
}

/**
 * Version callback for the Spout library.
 *
 * @param array $library
 *   An array of library information from hook_libraries_info().
 *
 * @return string
 */
function commerce_xls_import_spout_version($library) {
  // The version is not available in composer.json so we don't have anything to
  // go off of here.
  return 'N/A';
}

/**
 * Load the handler for a field type.
 *
 * @param string $field_type
 *   The type of field defined by hook_field_info().
 *
 * @return CommerceXlsImportValueHandlerInterface
 *
 * @see hook_commerce_xls_import_field_type_handler_info()
 * @see hook_commerce_xls_import_field_type_handler_info_alter()
 */
function commerce_xls_import_field_type_handler($field_type) {
  $handlers = &drupal_static(__FUNCTION__, array());

  if (empty($handlers)) {
    $handlers = module_invoke_all('commerce_xls_import_field_type_handler_info');
    drupal_alter('commerce_xls_import_field_type_handler_info', $handlers);
  }

  $handler = (isset($handlers[$field_type])) ? $handlers[$field_type] : $handlers['default'];
  return $handler['class_name'];
}

/**
 * Implements hook_commerce_xls_import_field_type_handler_info().
 *
 * Provide a default field type handler.
 */
function commerce_xls_import_commerce_xls_import_field_type_handler_info() {
  $handlers['default'] = array(
    'class_name' => 'CommerceXlsImportTextHandler',
  );

  $handlers['boolean'] = array(
    'class_name' => 'CommerceXlsImportBooleanHandler',
  );

  $handlers['commerce_price'] = array(
    'class_name' => 'CommerceXlsImportCommercePriceHandler',
  );

  $handlers['commerce_product_reference'] = array(
    'class_name' => 'CommerceXlsImportCommerceProductReferenceHandler',
  );

  $handlers['entityreference'] = array(
    'class_name' => 'CommerceXlsImportEntityReferenceHandler',
  );

  $handlers['image'] = array(
    'class_name' => 'CommerceXlsImportImageHandler',
  );

  $handlers['language'] = array(
    'class_name' => 'CommerceXlsImportLanguageHandler',
  );

  $handlers['list_boolean'] = array(
    'class_name' => 'CommerceXlsImportListBooleanHandler',
  );

  $handlers['number_decimal'] = array(
    'class_name' => 'CommerceXlsImportNumberDecimalHandler',
  );

  $handlers['sku'] = array(
    'class_name' => 'CommerceXlsImportSkuHandler',
  );

  $handlers['taxonomy_term_reference'] = array(
    'class_name' => 'CommerceXlsImportTaxonomyTermReferenceHandler',
  );

  $handlers['text'] = $handlers['default'];

  $handlers['text_with_summary'] = array(
    'class_name' => 'CommerceXlsImportTextWithSummaryHandler',
  );

  $handlers['variation_title'] = array(
    'class_name' => 'CommerceXlsImportVariationTitleHandler',
  );

  return $handlers;
}

/**
 * Determines whether an import is currently running in the background.
 *
 * Returns True if one is running, otherwise false.
 *
 * @return bool
 *  A boolean value representing whether an import is running or not.
 */
function commerce_xls_import_is_running() {
  $result = db_select('commerce_xls_import', 'ci')
    ->fields('ci', array('status'))
    ->condition('status', 'pending')
    ->execute();

  if (isset($result)) {
    return $result->rowCount();
  }
  else {
    return FALSE;
  }
}

/**
 * Setins current import to finished.
 */
function commerce_xls_import_set_finish_import() {
  // Set all updates to stopped status.
  $result = db_update('commerce_xls_import')
    ->fields(array('status' => 'finished'))
    ->execute();

  if ($result) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Stops current import.
 *
 * @return bool
 *  A boolean value representing whether the import was successfully stopped or not.
 */
function commerce_xls_import_stop_import() {
  // Set all updates to stopped status.
  $result = db_update('commerce_xls_import')
    ->fields(array(
      'status' => 'stopped',
    ))
    ->execute();

  if ($result) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Check to see if current import has been stopped.
 *
 * @return bool
 *  A boolean value representing whether the current has been stopped or not.
 */
function commerce_xls_import_stopped() {
  $result = db_select('commerce_xls_import', 'i')
    ->fields('i', array('status'))
    ->execute()
    ->fetchAssoc();

  if ($result['status'] == 'stopped') {
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Main function for the drupal commerce XLS export.
 *
 * @param string $op
 *   A string representing the respective operation to be performed.
 * @param array $product_info
 *   An array containing product information.
 * @param string $product_type
 *   The commerce_product type for the export.
 * @param string $display_type
 *   The node type for the export.
 */
function commerce_xls_import_export($op, $product_info = NULL, $product_type = NULL, $display_type = NULL) {
  module_load_include('inc', 'commerce_xls_import', 'includes/commerce_xls_import.errors');

  CommerceXlsImportSettings::setAliases(variable_get('commerce_xls_import_field_aliases', array()));

  $data = array('Products' => array());
  $headers = commerce_xls_import_generate_headers($product_type, $display_type);
  $options = array('format' => 'xls', 'title' => t('Product Import Template'));

  if ($product_info != NULL && $op != 'template') {
    $data['Products'] = $product_info;
  }

  switch ($op) {
    case 'errors':
      if (!commerce_xls_import_generate_errors_xls($options, $headers, $data)) {
        // If error, refresh page to display error.
        drupal_goto('admin/commerce/products/import_commerce');
      }
      break;

    case 'template':
      if (!commerce_xls_import_generate_template_xls($product_type, $headers, $data, $options)) {
        // If error, refresh page to display error.
        drupal_goto('admin/commerce/products/import_commerce');
      }

      break;
  }
}

//TODO - we should probably split this into 1 function that does the actual generation and 1 that just provides the download
/**
 * Generate template xls.
 *
 * @return bool
 *    Returns TRUE upon success and False upon failure.
 */
function commerce_xls_import_generate_template_xls($product_type, $headers, $data, $options) {
  libraries_load('spout');

  $filename = $product_type . '_template.xlsx';
  $path = file_build_uri($filename);

  if (file_exists($path)) {
    file_unmanaged_delete($path);
  }

  $writer = WriterFactory::create(Type::XLSX);
  $writer->openToFile(drupal_realpath($path));
  $writer->addRow($headers);
  $writer->addRows($data);
  $writer->close();

  header('Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
  header('Content-Disposition: attachment;filename="' . $filename . '"');
  header('Cache-Control: max-age=0');

  return TRUE;
}

/**
 * Main starting function for the drupal commerce XLS import.
 *
 * Extracts product_images.zip, then imports XLS file. If the XLS import is
 * successful the results will then be processed and the import will be started.
 *
 * @param array $file
 *   The XLS file info array containing product data to be imported.
 * @param bool $validate
 *   If true, don't create products. Otherwise create products.
 */
function commerce_xls_import_main($file, $validate = FALSE) {
  module_load_include('inc', 'commerce_xls_import', 'includes/commerce_xls_import.errors');

  // Get the product type.
  $product_type = $file['product_type'];
  $display_type = $file['display_type'];

  if($validate) {
    //I think there currently isn't any validate functionality?
    CommerceXlsImportSettings::setValidate();
  }

  variable_set('commerce_xls_import_import_count_status', array(
    'completed' => 0,
    'total' => 0
  ));

  // Extract product images.
  $archive_path = drupal_realpath(CommerceXlsImportSettings::imageZipUri());
  commerce_xls_import_unpack_zip(CommerceXlsImportSettings::imageExtractPath(), $archive_path);
  commerce_xls_import_import_process($file, $product_type, $display_type);
}

/**
 * Import process function.
 *
 * @param array $file
 *   The file to be processed.
 * @param $product_type
 *   The commerce_product bundle to be processed.
 * @param $display_type
 *   The node bundle to be processed.
 */
function commerce_xls_import_import_process($file, $product_type, $display_type) {
  libraries_load('spout');
  module_load_include('inc', 'commerce_xls_import', 'includes/commerce_xls_import.errors');

  CommerceXlsImportSettings::setAliases(variable_get('commerce_xls_import_field_aliases', array()));

  // 5 minutes should be more than enough to process 100 products at a time..
  set_time_limit(300);

  // Set up our PHP Excel variables.
  $filepath = drupal_realpath($file['uri']);
  $reader = ReaderFactory::create(Type::XLSX);
  $reader->open($filepath);

  $filepath = drupal_realpath(file_build_uri('product_import_results.xlsx'));
  $writer = WriterFactory::create(Type::XLSX);
  $writer->openToFile($filepath);

  $style_success = (new StyleBuilder())
    ->setBackgroundColor(Color::GREEN)
    ->build();

  $style_error = (new StyleBuilder())
    ->setShouldWrapText()
    ->setBackgroundColor(Color::RED)
    ->build();

  if (commerce_xls_import_stopped()) {
    return;
  }

  // Populate our row array.
  $count = 0;
  foreach ($reader->getSheetIterator() as $sheet) {
    $index = 0;
    $headers_set = false;
    foreach($sheet->getRowIterator() as $row) {
      //headers row
      if (!$headers_set) {
        $headers = array();
        // Populate headers from the first row of the sheet.
        foreach ($row as $header) {
          $headers[] = $header;
        }

        //add extra column for import errors
        $headers[] = 'ERRORS';
        $writer->addRow($headers);

        $headers_set = true;
        continue;
      }

      $possible_fields = commerce_xls_import_get_possible_fields($product_type, $display_type);
      //map into assoc array
      $data = array();
      foreach($row as $key => $value){
        $data[$headers[$key]] = $value;
      }
      $values = commerce_xls_import_get_values_by_entity_type($data, $possible_fields);
      // Test for required fields.
      $title = isset($values['node']['title']) ? $values['node']['title'] : NULL;
      $sku = isset($values['commerce_product']['sku']) ? $values['commerce_product']['sku'] : NULL;
      $price = isset($values['commerce_product']['commerce_price']) ? $values['commerce_product']['commerce_price'] : NULL;

      $node = commerce_xls_import_load_node_by_title($title, $display_type);
      if (empty($title)) {
        commerce_xls_import_set_error($index, 'title', t("Product doesn't have a title."));
      }
      elseif (empty($sku)) {
        commerce_xls_import_set_error($index, 'sku', t("Product doesn't have a sku."));
      }
      elseif (empty($price)) {
        commerce_xls_import_set_error($index, 'sku', t("Product doesn't have a price."));
      }
      else {
        if (!$node) {
          $node = new stdClass();
          $node->type = $display_type;
        }

        /** @var EntityDrupalWrapper $node_wrapper */
        $node_wrapper = entity_metadata_wrapper('node', $node);

        $product = commerce_product_load_by_sku($sku, TRUE);
        if (!$product) {
          $product = commerce_product_new($product_type);
        }
        /** @var EntityDrupalWrapper $product_wrapper */
        $product_wrapper = entity_metadata_wrapper('commerce_product', $product);

        foreach (array('commerce_product', 'node') as $entity_type) {
          foreach ($values[$entity_type] as $field_name => $value) {
            $field_type = $possible_fields[$entity_type][$field_name];
            $handler = commerce_xls_import_field_type_handler($field_type);
            // Pass in the appropriate wrapper based on entity type.
            $wrapper = ($entity_type === 'commerce_product') ? $product_wrapper : $node_wrapper;
            try {
              $set = $handler::set($value, $wrapper, $field_name);
              if ($set['status'] === COMMERCE_XLS_IMPORT_DATA_ERROR) {
                $message = (!empty($set['message'])) ? $set['message'] : t('Unknown error.');
                commerce_xls_import_set_error($index, $field_name, $message);
              }
            } catch (Exception $e) {
              commerce_xls_import_set_error($index, $field_name, $e->getMessage());
            }
          }
        }

        $row_has_errors = commerce_xls_import_get_row_error($index);
        if (CommerceXlsImportSettings::isImport() && !$row_has_errors) {
          $product_wrapper->save();
        }

        // If the node does not already reference the new product, set it now.
        $referenced_products = $node_wrapper->field_product->value();
        if (!empty($referenced_products)) {
          $product_already_referenced = FALSE;

          if (!is_array($referenced_products)) {
            $referenced_products = array($referenced_products);
          }

          foreach ($referenced_products as $referenced_product) {
            if ($referenced_product->product_id === $product->product_id) {
              $product_already_referenced = TRUE;
              break;
            }
          }

          if (!$product_already_referenced) {
            $referenced_products[] = $product;
            $node_wrapper->field_product = $referenced_products;
          }
        }

        if (CommerceXlsImportSettings::isImport() && !$row_has_errors) {
          $node_wrapper->save();
        }
      }

      // Squash values array to remove entity type.
      $values = $values['commerce_product'] + $values['node'];
      // Use numeric values for column index.
      $row_values = array();
      foreach ($headers as $name) {
        $name = CommerceXlsImportSettings::field_name($name);
        if (isset($values[$name])) {
          $row_values[] = $values[$name];
        }
      }

      $errors = '';
      foreach($data as $key => $value) {
        $row_error = commerce_xls_import_get_error($index, $key);
        if($row_error != '') {
          if($errors != ''){
            $errors .= "\n";
          }
          $errors .= $key . ': ' . $row_error;
        }
      }

      $row_values[] = $errors;

      if($errors == '') {
        $style = $style_success;
      }
      else{
        $style = $style_error;
      }
      $writer->addRowWithStyle($row_values, $style);

      $index++;
    }
    $count += $index;
  }

  $reader->close();
  $writer->close();

  variable_set('commerce_xls_import_last_import', array(
    'completed' => time(),
    'row' => $count,
    'total' => $count,
  ));

  commerce_xls_import_set_finish_import();

  if (CommerceXlsImportSettings::isImport()) {
    drupal_set_message(t('Import Completed, @count records imported', array('@count' => $count)));
  }
  else {
    drupal_set_message(t('Validate Completed, @count records checked', array('@count' => $count)));
  }
}

/**
 * process function for the product export.
 *
 * @param $product_type
 *   The product type to be processed.
 * @param string $display_type
 *   The product display type to be processed.
 */
function commerce_xls_import_export_process($product_type, $display_type) {
  libraries_load('spout');

  CommerceXlsImportSettings::setAliases(variable_get('commerce_xls_import_field_aliases', array()));

  $filepath = drupal_realpath(commerce_xls_import_export_filepath($display_type));
  $writer = WriterFactory::create(Type::XLSX);
  $writer->openToFile($filepath);

  $processed = commerce_xls_import_generate_records($writer, $product_type, $display_type);

  $writer->close();

  drupal_set_message(t('@processed products exported', array('@processed' => $processed)));
}

/**
 * @param Spout/Writer $writer
 *   The Spout writer object.
 * @param string $product_type
 *   The commerce_product bundle to export.
 * @param string $display_type
 *   The node bundle to export.
 * @param int $offset
 *   The number of products exported so far.
 * @param int $batch_size
 *   The number of records to generate.
 *
 * @return int
 *   The number of records processed.
 */
function commerce_xls_import_generate_records($writer, $product_type, $display_type) {
  $products_processed = 0;
  // Track if we've written headers to the file so we don't do it more than
  // once.

  $query = db_select('node', 'n');
  $query->addField('n', 'nid');
  $query->orderBy('n.nid');
  $query->condition('n.type', $display_type);
  $result = $query->execute();

  $field_info = commerce_xls_import_get_possible_fields($product_type, $display_type);
  $headers = array();
  $sheet_headers = array();
  $headers_list = commerce_xls_import_generate_headers($product_type, $display_type);
  foreach ($headers_list['Products'] as $field_name) {
    // Create an array keyed by the column header with an empty string that will
    // serve as the default value of each column.
    $headers[CommerceXlsImportSettings::field_alias($field_name)] = '';
    $sheet_headers[] = CommerceXlsImportSettings::field_alias($field_name);
  }

  $writer->addRow($sheet_headers);

  foreach ($result as $row) {
    $product_display = node_load($row->nid, NULL, TRUE);

    /** @var EntityDrupalWrapper $node_wrapper */
    $node_wrapper = entity_metadata_wrapper('node', $product_display);
    $product_wrappers = $node_wrapper->field_product;
    // Ensure that we can iterate over a list of products, even if the field has
    // a cardinality of one.
    if (is_object($product_wrappers) && get_class($product_wrappers) !== 'EntityListWrapper') {
      $product_wrappers = array($product_wrappers);
    }

    // Get node data.
    $node_data = array();
    foreach ($field_info['node'] as $field_name => $field_type) {
      $handler = commerce_xls_import_field_type_handler($field_type);
      $node_data[CommerceXlsImportSettings::field_alias($field_name)] = $handler::get($node_wrapper, $field_name);
    }

    foreach ($product_wrappers as $product_wrapper) {
      /** @var EntityDrupalWrapper $product_wrapper */
      $data = $node_data;
      foreach ($field_info['commerce_product'] as $field_name => $field_type) {
        $handler = commerce_xls_import_field_type_handler($field_type);
        $data[CommerceXlsImportSettings::field_alias($field_name)] = $handler::get($product_wrapper, $field_name);
      }

      // Put keys in proper order for export.
      $data = array_merge($headers, $data);
      $data = array_values($data);

      $writer->addRow($data);
    }

    $products_processed++;
  }

  return $products_processed;
}

/**
 * Load a node by its title.
 *
 * @param string $title
 *   The title of the node.
 *
 * @return object|array|FALSE
 *   The loaded node or FALSE if no node exists with the title. Returns an array
 *   of node ids if multiple are found.
 */
function commerce_xls_import_load_node_by_title($title, $bundle) {
  $node = FALSE;

  $query = new EntityFieldQuery();
  $results = $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', $bundle)
    ->propertyCondition('title', $title, '=')
    ->execute();

  if (isset($results['node'])) {
    $nids = array_map(function ($item) {
      return $item->nid;
    }, $results['node']);
    if (count($nids) === 1) {
      $nid = reset($nids);
      return node_load($nid);
    }
    elseif (count($nids) > 1) {
      return $nids;
    }
  }

  return $node;
}

/**
 * Key the values from the spreadsheet by entity type.
 *
 * @param array $row
 *   One row from the import spreadsheet.
 * @param array $possible_fields
 *   An array of field names and types keyed by entity type.
 *
 * @return array
 *   Returns the set values that correspond to the possible fields of the
 *   product type. Keys are the entity types commerce_product and node. Values
 *   are themselves arrays keyed by field name.
 *
 * @see commerce_xls_import_get_possible_fields()
 */
function commerce_xls_import_get_values_by_entity_type($row, $possible_fields) {
  $values = array();

  foreach ($possible_fields as $entity_type => $fields) {
    foreach($fields as $field_name => $field_type) {
      if (isset($row[CommerceXlsImportSettings::field_alias($field_name)])) {
        $values[$entity_type][$field_name] = $row[CommerceXlsImportSettings::field_alias($field_name)];
      }
    }
  }

  return $values;
}

/**
 * Extract files from a zip archive.
 *
 * @param string $extract_path
 *  The directory to extract the files to.
 *
 * @param string $filepath
 *  The path to the zip file.
 *
 * @return bool
 *  TRUE if file is zip file is successfully extracted, otherwise FALSE.
 */
function commerce_xls_import_unpack_zip($extract_path, $filepath) {
  $zip = new ZipArchive;
  $success = $zip->open($filepath);
  if ($success === TRUE) {
    // extract it to the path we determined above
    $success = $zip->extractTo($extract_path);
    $zip->close();
  }

  if($success){
    drupal_set_message(t('@filename extracted successfully to @extract_dir', array(
      '@filename' => basename($filepath),
      '@extract_dir' => $extract_path,
    )));
    return TRUE;
  }
  else{
    drupal_set_message(t('There was an error extracting @filename.zip. Please try again, if the problem persists contact the system administrator', array(
      '@filename' => basename($filepath),
    )), 'error');
    watchdog('commerce_xls_import', 'Error extracting zip file @filename', array('@filename' => $filepath));
    return FALSE;
  }


}

/**
 * Gets any fields or properties apply to products and nodes of the given types.
 *
 * @param string $product_type
 *   The commerce_product bundle to get fields for.
 * @param string $node_type
 *   The node bundle to get fields for.
 * @param bool $reset
 *   TRUE to reset the static cache.
 *
 * @return array
 *   An array where each key is a field or property name and the value is its
 *   type.
 */
function commerce_xls_import_get_possible_fields($product_type = NULL, $node_type = NULL, $reset = FALSE) {
  $fields = &drupal_static(__FUNCTION__, array());
  if (!$reset && !empty($fields)) {
    return $fields;
  }

  $fields = array(
    'commerce_product' => array(
      'commerce_price' => 'commerce_price',
      'language' => 'language',
      // Fake type "sku" to use CommerceXlsImportSkuHandler.
      'sku' => 'sku',
      // Fake type for setting the title of the product variation independently
      // of the node title.
      'variation_title' => 'variation_title',
      'status' => 'boolean',
    ),
    'node' => array(
      'language' => 'language',
      'status' => 'boolean',
      'title' => 'text',
    ),
  );

  $instances = field_info_instances('commerce_product', $product_type);
  foreach($instances as $field_name => $instance) {
    // Don't allow overwriting the default values in case we've used a custom
    // type.
    if (!isset($fields['commerce_product'][$field_name])) {
      $field = field_info_field($field_name);
      if (!CommerceXlsImportSettings::isExcluded($field['type'])) {
        $fields['commerce_product'][$field_name] = $field['type'];
      }
    }
  }

  $instances = field_info_instances('node', $node_type);
  if (isset($node_type)) {
    $instances = array($node_type => $instances);
  }

  foreach ($instances as $node_type => $node_fields) {
    foreach ($node_fields as $field_name => $instance) {
      // Don't allow overwriting the default values in case we've used a custom
      // type.
      if (!isset($fields['node'][$field_name])) {
        $field = field_info_field($field_name);
        if (!CommerceXlsImportSettings::isExcluded($field['type'])) {
          $fields['node'][$field_name] = $field['type'];
        }
      }
    }
  }

  return $fields;
}

/**
 * Gets an array containing all product NIDs by the given type.
 *
 * @param string $product_type
 *   The product type.
 *
 * @return array
 *   An array containing the NIDs of the given product type.
 */
function commerce_xls_import_nids_of_type($product_type) {
  $products = array();

  $result = db_select('node', 'n')
    ->fields('n', array('nid'))
    ->condition('n.type', $product_type, '=')
    ->execute();
  $records = $result->fetchAllAssoc('nid');

  foreach ($records as $key => $record) {
    $products[] = $key;
  }

  return $products;
}

/**
 * Get the headers needed for the export and import template.
 *
 * @param string $product_type
 *   The product type for the selected import.
 * @param string $display_type
 *   The node type for the selected import.
 *
 * @return array $headers
 *
 */
function commerce_xls_import_generate_headers($product_type = NULL, $display_type = NULL) {
  $fields = commerce_xls_import_get_possible_fields($product_type, $display_type, TRUE);
  $headers = array_keys($fields['commerce_product'] + $fields['node']);
  $headers = array_map(array('CommerceXlsImportSettings', 'field_alias'), $headers);
  $headers = array('Products' => $headers);
  return $headers;
}

/**
 * Gets the owner of the form field.
 *
 * @param string $field_name
 *  The field name to check ownwership against.
 *
 * @return string
 *  The owner of the given field
 *
 */
function commerce_xls_import_get_field_owner($field_name) {
  if ($field_name == 'title') {
    return 'parent';
  }
  elseif ($field_name == 'variation_title') {
    return 'variation';
  }
  elseif ($field_name == 'sku') {
    return 'variation';
  }
  elseif ($field_name == 'status') {
    return 'both';
  }
  elseif ($field_name == 'language') {
    return 'parent';
  }
  else {
    $field_info = field_info_field($field_name);
    if (isset($field_info['bundles']['commerce_product'])) {
      if (isset($field_info['bundles']['node'])) {
        return 'both';
      }
      else {
        return 'variation';
      }
    }
    else {
      return 'parent';
    }
  }
}

/**
 * Checks the status of the current import.
 */
function commerce_xls_import_current_status() {
  $current = variable_get('commerce_xls_import_import_count_status', '');

  $is_running = commerce_xls_import_is_running();

  if (($current == '' && $is_running)) {
    $message = t('Working...');
    $status = 0;
  }
  elseif ($current == '' && !$is_running) {
    $message = t('Done');
    $status = 1;
    variable_set('commerce_xls_import_completed', 1);
  }
  else {
    $message = t('Status : @current/@total products evaluated with @errors errors',
      array(
        '@current' => $current['completed'],
        '@total' => $current['total'],
        '@errors' => commerce_xls_import_count_errors(),
      ));
    $message .= '<br /><progress id="commerce-xls-import-progress" value=' . $current['completed'] . ' max=' . $current['total'] . ' style="clear:both"></progress>';
    $status = 0;
  }

  if ($current == '') {
    $output = array(
      'completed' => 0,
      'total' => 0,
      'message' => $message,
      'status' => $status,
    );
  }
  else {
    $output = array(
      'completed' => $current['completed'],
      'total' => $current['total'],
      'message' => $message,
      'status' => $status,
    );
  }

  drupal_json_output($output);
}

/**
 * Returns a URI to the location of the exported XLS file.
 *
 * If the "export" directory doesn't exist in files folder, it is created.
 *
 * @param string $display_type
 *   The node bundle to create the file path for.
 *
 * @return string
 *   The URI to the export file of the specified product type.
 */
function commerce_xls_import_export_filepath($display_type) {
  $export_uri = file_build_uri('export');
  // Create or update directory permissions as needed.
  file_prepare_directory($export_uri, FILE_CREATE_DIRECTORY | FILE_MODIFY_PERMISSIONS);
  return "{$export_uri}/commerce_xls_export_{$display_type}.xlsx";
}

/**
 * Checks to see if a file URI already exists in the managed file system.
 *
 * @param string $uri
 *   The URI to look for.
 * @param bool $reset
 *   If TRUE, the static cache will be reset.
 *
 * @return mixed
 *   Either the file ID of the file, or FALSE if it doesn't exist.
 */
function commerce_xls_import_file_entry_exists($uri, $reset = FALSE) {
  $entries = &drupal_static(__FUNCTION__, array());

  if ($reset) {
    $entries = array();
  }

  if (!isset($entries[$uri])) {
    $result = db_select('file_managed', 'f')
      ->fields('f', array('fid'))
      ->condition('f.uri', $uri, '=')
      ->execute();

    $fid = $result->fetchField();

    // Do not cache a not-found result since an image could occur later in the
    // import and should then find the FID from when it was created the first
    // time it occurred.
    if (empty($fid)) {
      return FALSE;
    }

    $entries[$uri] = $fid;
  }

  return $entries[$uri];
}
