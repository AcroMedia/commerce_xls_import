<?php
/**
 * @file
 * Imports Drupal Commerce Entities from an XLS file.
 *
 * Returns an XLS file highlighting success and failures.
 */

define('COMMERCE_XLS_IMPORT_DATA_ERROR', 0);
define('COMMERCE_XLS_IMPORT_DATA_SUCCESS', 1);

/**
 * Implements hook_menu().
 *
 * Adds menu items to generate the headers or begin the commerce XLS import.
 */
function commerce_xls_import_menu() {
  $items = array();

  $items['admin/commerce/products/import_commerce'] = array(
    'title' => 'Commerce Import',
    'description' => 'Import commerce XLS or generate XLS headers form',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_xls_import_start'),
    'access arguments' => array('administer commerce import'),
    'file' => 'includes/commerce_xls_import.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );

  $items['admin/commerce/products/import_commerce/export'] = array(
    'title' => 'Commerce Export',
    'description' => 'Export products to XLS.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_xls_import_start_export'),
    'access arguments' => array('administer commerce import'),
    'file' => 'includes/commerce_xls_import.export.inc',
  );

  $items['admin/commerce/products/import_commerce/get_import_status'] = array(
    'title' => 'Commerce Import Status Update',
    'description' => 'Update the status of the current commerce xls import',
    'page callback' => 'commerce_xls_import_current_status',
    'access arguments' => array('administer commerce import'),
    'file' => NULL,
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function commerce_xls_import_permission() {
  return array(
    'administer commerce import' => array(
      'title' => t('Administer Commerce XLS Import'),
      'description' => t('Perform an XLS import'),
    ),
  );
}

/**
 * Implements hook_theme().
 */
function commerce_xls_import_theme() {
  return array(
    'commerce_xls_import_instructions' => array(
      'file' => 'includes/commerce_xls_import.theme.inc',
      'template' => 'templates/commerce_xls_import_instructions',
      'variables' => array(),
    ),
  );
}

/**
 * Implements hook_phpexcel_export().
 */
function commerce_xls_import_phpexcel_export($op, &$data, &$phpexcel, $options, $column = NULL, $row = NULL) {

  switch ($op) {
    case 'headers':
      break;

    case 'new sheet':
      $phpexcel->getActiveSheet()->getProtection()->setSheet(FALSE);
      $phpexcel->getActiveSheet()->getProtection()->setSort(FALSE);
      break;

    case 'data':
      break;

    case 'pre cell':
      break;

    case 'post cell':
      $style_array = array();
      if ($row > 1) {
        // Have to convert header from number to column title to match with our
        // error recording there must be a more elegant way to do this but I
        // can't seem to figure one out.
        $headers = commerce_xls_import_get_headers($phpexcel);

        $column_status = commerce_xls_import_get_column_status($row, $headers[$column]);
        if (!CommerceXlsImportSettings::rowHasError($row)) {
          if ($column_status == COMMERCE_XLS_IMPORT_DATA_ERROR) {
            if ($headers[$column] == 'title') {
              CommerceXlsImportSettings::setRowErrorStatus($row);
            }
            $style_array = array(
              'fill' => array(
                'type' => PHPExcel_Style_Fill::FILL_SOLID,
                'startcolor' => array('argb' => '00FF9999'),
              ),
              'borders' => array(
                'allborders' => array(
                  'style' => PHPExcel_Style_Border::BORDER_THIN,
                  'color' => array('argb' => '00DA4141'),
                ),
              ),
            );
          }
          elseif ($column_status == COMMERCE_XLS_IMPORT_DATA_SUCCESS) {
            $style_array = array(
              'fill' => array(
                'type' => PHPExcel_Style_Fill::FILL_SOLID,
                'startcolor' => array('argb' => '0078FAA3'),
              ),
              'borders' => array(
                'allborders' => array(
                  'style' => PHPExcel_Style_Border::BORDER_THIN,
                  'color' => array('argb' => '0000994C'),
                ),
              ),
            );
          }
          else {
            $style_array = array(
              'fill' => array(
                'type' => PHPExcel_Style_Fill::FILL_NONE,
              ),
              'borders' => array(
                'allborders' => array(
                  'style' => PHPExcel_Style_Border::BORDER_NONE,
                ),
              ),
            );
          }
        }
        else {
          $style_array = array(
            'fill' => array(
              'type' => PHPExcel_Style_Fill::FILL_SOLID,
              'startcolor' => array('argb' => '00FFFF66'),
            ),
            'borders' => array(
              'allborders' => array(
                'style' => PHPExcel_Style_Border::BORDER_THIN,
                'color' => array('argb' => '00CCCC00'),
              ),
            ),
          );
        }
        if (CommerceXlsImportSettings::isImport() && isset($GLOBALS['nid_column']) && $GLOBALS['nid_column'] != $column) {
          $phpexcel->getStyleByColumnAndRow($column, $row)->getProtection()->setLocked(PHPExcel_Style_Protection::PROTECTION_UNPROTECTED);
        }
        else {
          $phpexcel->getStyleByColumnAndRow($column, $row)->getProtection()->setLocked(PHPExcel_Style_Protection::PROTECTION_PROTECTED);
        }

        $phpexcel->getStyleByColumnAndRow($column, $row)->applyFromArray($style_array);

      }
      else {
        // Header row - mark for variation or parent.
        $owner = commerce_xls_import_get_field_owner($data);

        // Mark nid row for locking.
        if ($data == 'nid') {
          $GLOBALS['nid_column'] = $column;
        }

        if ($owner == 'variation') {
          $style_array = array(
            'fill' => array(
              'type' => PHPExcel_Style_Fill::FILL_SOLID,
              'startcolor' => array('argb' => '00fac090'),
            ),
            'borders' => array(
              'allborders' => array(
                'style' => PHPExcel_Style_Border::BORDER_THIN,
                'color' => array('argb' => '00fac090'),
              ),
            ),
          );
        }
        elseif ($owner == 'parent') {
          $style_array = array(
            'fill' => array(
              'type' => PHPExcel_Style_Fill::FILL_SOLID,
              'startcolor' => array('argb' => '008db4e3'),
            ),
            'borders' => array(
              'allborders' => array(
                'style' => PHPExcel_Style_Border::BORDER_THIN,
                'color' => array('argb' => '008db4e3'),
              ),
            ),
          );
        }
        elseif ($owner == 'both') {
          $style_array = array(
            'fill' => array(
              'type' => PHPExcel_Style_Fill::FILL_SOLID,
              'startcolor' => array('argb' => '0024ABB7'),
            ),
            'borders' => array(
              'allborders' => array(
                'style' => PHPExcel_Style_Border::BORDER_THIN,
                'color' => array('argb' => '0024ABB7'),
              ),
            ),
          );
        }
        $phpexcel->getStyleByColumnAndRow($column, $row)->getProtection()->setLocked(PHPExcel_Style_Protection::PROTECTION_PROTECTED);
        $phpexcel->getStyleByColumnAndRow($column, $row)->applyFromArray($style_array);
      }
      break;
  }
}

/**
 * Determines whether an import is currently running in the background.
 *
 * Returns True if one is running, otherwise false.
 *
 * @return bool
 *  A boolean value representing whether an import is running or not.
 */
function commerce_xls_import_is_running() {
  $result = db_select('commerce_xls_import', 'ci')
    ->fields('ci', array('status'))
    ->condition('status', 'pending')
    ->execute();

  if (isset($result)) {
    return $result->rowCount();
  }
  else {
    return FALSE;
  }
}

/**
 * Setins current import to finished.
 */
function commerce_xls_import_set_finish_import() {
  global $user;

  // Set all updates to stopped status.
  $result = db_update('commerce_xls_import')
    ->fields(array('status' => 'finished'))
    ->condition('uid', $user->uid)
    ->execute();

  if ($result) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Stops current import.
 *
 * @return bool
 *  A boolean value representing whether the import was successfully stopped or not.
 */
function commerce_xls_import_stop_import() {
  // Set all updates to stopped status.
  $result = db_update('commerce_xls_import')
    ->fields(array(
      'status' => 'stopped',
    ))
    ->execute();

  if ($result) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Check to see if current import has been stopped.
 *
 * @return bool
 *  A boolean value representing whether the current has been stopped or not.
 */
function commerce_xls_import_stopped() {
  $result = db_select('commerce_xls_import', 'i')
    ->fields('i', array('status'))
    ->execute()
    ->fetchAssoc();

  if ($result['status'] == 'stopped') {
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Main function for the drupal commerce XLS export.
 *
 * @param string $op
 *  A string representing the respective operation to be performed.
 *
 * @param array $product_info
 *  An array containing product information.
 *
 * @param string $product_type
 *  A string representing the currenty product's product type.
 *
 * @param array $nids
 *  An array of node ids.
 */
function commerce_xls_import_export($op, $product_info = NULL, $product_type = NULL, $display_type = NULL, $nids = FALSE) {
  module_load_include('inc', 'phpexcel');
  module_load_include('inc', 'commerce_xls_import', 'includes/commerce_xls_import.errors');

  // NOTE: This is required because the phpexcel module gives strict warnings
  // with its export functionality.
  error_reporting(E_ALL ^ E_STRICT);

  $data = array('Products' => array());
  $headers = commerce_xls_import_generate_headers($nids, $product_type, $display_type);
  $options = array('format' => 'xls', 'title' => t('Product Import Template'));

  if ($product_info == NULL || $op == 'template') {
    $data['Products'][] = array();
  }
  else {
    $count = 1;
    foreach ($product_info as $row) {
      $count++;
      $new_data_array = array();

      //TODO - what on earth is the purpose of this?
      foreach ($row as $new) {
        $new_data_array[] = $new;
      }

      if (CommerceXlsImportSettings::isImport() && ($nids || commerce_xls_import_get_row_error($count))) {
        $array_pos = count($new_data_array) - 1;
        if ($headers['Products'][$array_pos] == 'nid') {
          $new_data_array[$array_pos] = $row['nid'];
        }
      }

      $data['Products'][] = $new_data_array;
    }
  }

  switch ($op) {
    case 'export':
      if (!commerce_xls_import_export_xls($product_type, $options, $headers, $data)) {
        // If error, refresh page to display error.
        drupal_goto('admin/commerce/products/import_commerce');
      }
      break;

    case 'errors':
      if (!commerce_xls_import_generate_errors_xls($options, $headers, $data)) {
        // If error, refresh page to display error.
        drupal_goto('admin/commerce/products/import_commerce');
      }
      break;

    case 'template':
      if (!commerce_xls_import_generate_template_xls($product_type, $headers, $data, $options)) {
        // If error, refresh page to display error.
        drupal_goto('admin/commerce/products/import_commerce');
      }

      break;
  }
}

/**
 * Generate template xls.
 *
 * @return bool
 *    Returns TRUE upon success and False upon failure.
 */
function commerce_xls_import_generate_template_xls($product_type, $headers, $data, $options) {
  $filename = $product_type . '_template.xls';
  $path = file_build_uri($filename);

  if (file_exists($path)) {
    file_unmanaged_delete($path);
  }
  $result = phpexcel_export($headers, $data, drupal_realpath($path), $options);

  if ($result == PHPEXCEL_SUCCESS) {
    header('Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    header('Content-Disposition: attachment;filename="' . $filename . '"');
    header('Cache-Control: max-age=0');

    return TRUE;
  }
  else {
    drupal_set_message(t('PHPExcel error @result', array('@result' => $result)), 'error');
    drupal_set_message(t('There was an error generating the template. If this persists, contact the system administrator'), 'error');

    return FALSE;
  }
}

/**
 * Generate product_import_results.xls.
 *
 * @return bool
 *    Returns TRUE upon success and False upon failure.
 */
function commerce_xls_import_generate_errors_xls($options, $headers, $data) {
  $filename = 'product_import_results.xls';
  $path = file_build_uri($filename);
  $options['errors'] = TRUE;

  if (file_exists($path)) {
    file_unmanaged_delete($path);
  }
  $result = phpexcel_export($headers, $data, drupal_realpath($path), $options);

  if ($result == PHPEXCEL_SUCCESS) {
    header('Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    header('Content-Disposition: attachment;filename="' . $filename . '"');
    header('Cache-Control: max-age=0');

    return TRUE;
  }
  else {
    drupal_set_message(t('PHPExcel error @result', array('@result' => $result)), 'error');
    drupal_set_message(t('There was an error generating the import result document. Please try again. If this problem persists, contact the system administrator'), 'error');

    return FALSE;
  }
}

/**
 * Generate product_export.xls.
 *
 * @return bool
 *    Returns TRUE upon success and False upon failure.
 */
function commerce_xls_import_export_xls($product_type, $options, $headers, $data) {
  $filename = $product_type . '_export.xls';
  $path = file_build_uri($filename);

  if (file_exists($path)) {
    file_unmanaged_delete($path);
  }
  $result = phpexcel_export($headers, $data, drupal_realpath($path), $options);

  if ($result == PHPEXCEL_SUCCESS) {
    header('Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    header('Content-Disposition: attachment;filename="' . $filename . '"');
    header('Cache-Control: max-age=0');

    return TRUE;
  }
  else {
    drupal_set_message(t('PHPExcel error @result', array('@result' => $result)), 'error');
    drupal_set_message(t('There was an error generating the import result document. Please try again. If this problem persists, contact the system administrator'), 'error');

    return FALSE;
  }
}

/**
 * Main batch function for the drupal commerce XLS import.
 *
 * Extracts product_images.zip, then imports XLS file. If the XLS import is
 * successful the results will then be processed and the import will be started.
 *
 * @param null|array $file
 *   The XLS file info array containing product data to be imported.
 * @param bool $validate
 *   If true, don't create products. Otherwise create products.
 */
function commerce_xls_import_batch_start($file, $validate = FALSE) {
  module_load_include('inc', 'commerce_xls_import', 'includes/commerce_xls_import.errors');

  variable_set('commerce_xls_import_error_count', 0);

  // Get the product type.
  $product_type = $file['product_type'];
  $display_type = $file['display_type'];

  // Extract product images.
  $images_info = commerce_xls_import_extract_zip();

  $batch = array(
    'operations' => array(
      array('commerce_xls_import_batch_begin', array($validate)),
      array('commerce_xls_import_batch_process', array($file, $product_type, $display_type, $images_info)),
      array('commerce_xls_import_batch_wrapup', array($product_type, $display_type)),
    ),
    'finished' => 'commerce_xls_import_batch_finished',
    'title' => t('Processing Import'),
    'init_message' => t('Import is starting.'),
    'progress_message' => t('Import in progress...'),
    'error_message' => t('Import has encountered an error.'),
  );

  batch_set($batch);
}

/**
 * Batch begin function, sets up initial status values
 *
 * @param $validate bool flag if this is validate-only
 */
function commerce_xls_import_batch_begin($validate) {
  if($validate) {
    CommerceXlsImportSettings::setValidate();
  }
  variable_set('commerce_xls_import_import_count_status', array('completed' => 0, 'total' => 0));
}

/**
 * Batch process function, each process 100 elements.
 *
 * @param $file the file to be processed
 * @param $product_type the product type to be processed
 * @param $display_type the paired display type to be processed
 * @param $images_info the image bundle info
 * @param $context the batch context to continue
 */
function commerce_xls_import_batch_process($file, $product_type, $display_type, $images_info, &$context) {
  libraries_load('PHPExcel');
  module_load_include('inc', 'phpexcel', 'phpexcel');
  module_load_include('inc', 'commerce_xls_import', 'includes/commerce_xls_import.errors');

  // 5 minutes should be more than enough to process 100 products at a time..
  set_time_limit(300);

  // Set up our PHP Excel variables.
  $filepath = drupal_realpath($file['uri']);

  $reader = PHPExcel_IOFactory::createReaderForFile($filepath);
  $filter = new CommerceXlsImportReadFilter();
  $reader->setReadFilter($filter);

  if (empty($context['sandbox']['progress'])) {
    $context['sandbox']['progress'] = 0;
    $file_info = $reader->listWorksheetInfo($filepath);

    $context['sandbox']['total_rows'] = $file_info[0]['totalRows'];
    $context['sandbox']['total_columns'] = $file_info[0]['totalColumns'];
    $context['sandbox']['headers'] = array();
    $context['sandbox']['nids'] = array();

    $file_info = NULL;
  }

  $chunk_size = 100;
  // PHPExcel counts rows starting at 1, not 0, so the starting row needs to
  // be adjusted.
  $start_row = $context['sandbox']['progress'] + 1;

  if (($context['sandbox']['progress'] + $chunk_size) > $context['sandbox']['total_rows']) {
    // Adjust the chunk size if we're going to get pushed past the total number
    // of rows in the excel file.
    $chunk_size = $context['sandbox']['total_rows'] - $context['sandbox']['progress'];
  }

  $filter->setRows($start_row, $start_row + $chunk_size);
  $objPHPExcel = $reader->load($filepath);
  $active_sheet = $objPHPExcel->getActiveSheet();

  for ($i = 0; $i < $chunk_size; $i++) {

    if (commerce_xls_import_stopped()) {
      return;
    }

    // Manually flush Drupal's static caches when we start a new chunk
    entity_get_controller('node')->resetCache();
    entity_get_controller('commerce_product')->resetCache();
    $row = array();

    // Populate our row array.
    for ($col_count = 0; $col_count < $context['sandbox']['total_columns']; $col_count++) {
      if ($cell = $active_sheet->getCellByColumnAndRow($col_count, $i + $start_row)) {
        // Headers needed to be populated first.
        if ($start_row == 1 && $i == 0) {
          $context['sandbox']['headers'][] = $cell->getValue();
        }
        else {
          $row[$context['sandbox']['headers'][$col_count]] = $cell->getValue();
        }
      }
      else {
        break;
      }
    }

    // If $row is empty it means that we're only on the header row.
    if (!empty($row)) {

      if ($row['title'] == NULL) {
        commerce_xls_import_set_error($i + $start_row, 'title', "Product doesn't have a title");
        $has_errors = TRUE;
      }
      else {
        $has_errors = FALSE;
      }

      if (!$has_errors) {
        $values = commerce_xls_import_get_product_values($row, $product_type, $display_type);
        if (!isset($row['nid']) || $row['nid'] == NULL) {
          // If nid is set it is a line from a resubmitted results.xls.
          $entity_info = commerce_xls_import_set_entity_values($row);
          $nid = commerce_xls_import_create_product($i + $start_row, $values, $entity_info, $product_type, $display_type, $images_info);
        }
        else {
          // If nid isn't null ignore it as it was already imported.
          $nid = $row['nid'];
          commerce_xls_import_set_error($i + $start_row, 'nid', 'nis was already imported');
        }
      }
      else {
        $nid = NULL;
      }
      $context['sandbox']['nids'][$i + $start_row] = $nid;

      variable_set('commerce_xls_import_import_count_status', array('completed' => $context['sandbox']['progress'], 'total' => $context['sandbox']['total_rows'] - 1));

      $context['results'][] = $row;
    }

    // Update progress info
    $context['sandbox']['progress'] ++;
    $context['message'] = t('@count records have been processed.', array('@count' => $context['sandbox']['progress']));
  }

  // Add NIDs to each product.
  if (CommerceXlsImportSettings::isImport()) {
    $count = 0;
    foreach ($context['sandbox']['nids'] as $nid) {
      $context['results'][$count]['nid'] = $nid;
      $count++;
    }
  }

  // Inform the batch engine that we are not finished,
  // and provide an estimation of the completion level we reached.
  if ($context['sandbox']['progress']!= $context['sandbox']['total_rows']) {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['total_rows'];
  }

  $objPHPExcel->disconnectWorksheets();
  $objPHPExcel = NULL;
}

/**
 * Batch wrapup function.
 */
function commerce_xls_import_batch_wrapup($product_type, $display_type, &$context) {
  // Skip this step if errors were encountered.
  if (!empty($context['results']['has_errors'])) {
    return;
  }

  $context['message'] = t('@count products processed.', array('@count' => count($context['results'])));

  $import_counts = variable_get('commerce_xls_import_import_count_status', '');
  variable_set('commerce_xls_import_last_import', array(
    'completed' => time(),
    'row' => $import_counts['completed'],
    'total' => $import_counts['total'],
  ));
  variable_del('commerce_xls_import_import_count_status');
  commerce_xls_import_export('errors', $context['results'], $product_type, $display_type, TRUE);
  commerce_xls_import_set_finish_import();
}

/**
 * Batch completion callback.
 */
function commerce_xls_import_batch_finished($success, $results, $operations) {
  if (!empty($results['has_errors'])) {
    drupal_set_message(t('Import encountered problems with the Excel file.'), 'error');
    return;
  }

  if ($success) {
    // Here we do something meaningful with the results.
    $message = t('@count products successfully processed', array('@count' => count($results)));
    drupal_set_message($message);
  }
  else {
    // An error occurred.
    // $operations contains the operations that remained unprocessed.
    $error_operation = reset($operations);
    $message = t('An error occurred while processing %error_operation with arguments: @arguments', array('%error_operation' => $error_operation[0], '@arguments' => print_r($error_operation[1], TRUE)));
    drupal_set_message($message, 'error');
  }
}

/**
 * Sets entity values.
 *
 * @param array $product
 *   The product array the entity is being created from.
 *
 * @return array
 *   An array containing all of the set entity values for the product.
 */
function commerce_xls_import_set_entity_values(array $product) {
  global $user;

  $entity_info = array(
    'status' => isset($product['status']) ? $product['status'] : NULL,
    'uid' => $user->uid,
    'sku' => isset($product['sku']) ? $product['sku'] : NULL,
    'title' => isset($product['title']) ? $product['title'] : NULL,
    'variation_title' => isset($product['variation_title']) ? $product['variation_title'] : (isset($product['title']) ? $product['title'] : NULL),
    'language' => isset($product['language']) ? $product['language'] : NULL,
    'categories' => isset($product['field_product_category']) ? $product['field_product_category'] : NULL,
    'body' => isset($product['body']) ? $product['body'] : NULL,
    'nid' => isset($product['nid']) ? $product['nid'] : NULL,
  );

  return $entity_info;
}

/**
 * Gets an array containing the set values of the product.
 *
 * Gets the field data from the product type and then creates an array that
 * contains the set data from the given product.
 *
 * @param array $product
 *   Product to be imported.
 * @param string $product_type
 *   The product type.
 *
 * @return array
 *   Returns the set values that correspond to the possible fields of the
 *   product type.
 */
function commerce_xls_import_get_product_values(array $product, $product_type, $display_type) {
  $values = array(
    'currency_code' => commerce_default_currency(),
  );

  $possible_fields = commerce_xls_import_get_possible_fields($product_type, $display_type);

  foreach ($possible_fields as $field) {
    if (isset($product[$field])) {
      $values[$field] = $product[$field];
    }
  }

  return $values;
}

/**
 * Checks to see if the language table exists.
 *
 * If it does then it checks the languages table for a corresponding language.
 *
 * Returns the language if a match is found, false if the table does not
 * exist or no language match found.
 *
 */
function commerce_xls_import_validate_languages($language) {
  if (db_table_exists('languages')) {
    $result = db_select('languages', 'l')
      ->fields('l', array('language', 'name'))
      ->execute();
    while ($record = $result->fetchAssoc()) {
      if ((strtolower($record['language']) == strtolower($language)) || strtolower($language) == strtolower($record['name'])) {
        return $record['language'];
      }
    }
  }

  return FALSE;
}

/**
 * Validates the product by title and returns nid if it exists.
 *
 * If one or no products with the same name exists, return nid. Otherwise
 * return false.
 *
 * @return bool
 *    True if product is valid.
 */
function commerce_xls_import_validate_product($row, $entity_info) {
  $nid = NULL;

  if (!isset($entity_info['nid']) || $entity_info['nid'] == NULL) {
    $nid = commerce_xls_import_search_for_product($entity_info['title']);
  }
  else {
    $nid = $entity_info['nid'];
  }

  // Validate nid.
  if (is_array($nid)) {
    // Multiple possible nid's mark warning and do not proceed any further.
    commerce_xls_import_set_error($row, 'nid', 'Multiple product matches found');

    return FALSE;
  }

  return $nid;
}

/**
 * Checks image validity and sets it in the form_state if valid.
 *
 * @param int $row
 *  Current row in spreadsheet.
 *
 * @param array|string $field
 *  Value or values of image name(s).
 *
 * @param array $form_state
 *  The form state array.
 *
 * @param array $image_info
 *  Contains image file info.
 *
 * @param string $key
 *  Index representing the column name in the current row.
 *
 * @param string $language
 *  Represents the language being used.
 */
function commerce_xls_import_check_set_images($row, $field, &$form_state, $image_info, $key, $language) {
  // it's an image, check whether multiple uploads.
  $filenames = array($field);
  if (strpos($field, ',')) {
    $filenames = explode(',', $field);
  }

  foreach ($filenames as $filename) {
    if ($filename != '') {
      if (pathinfo($filename, PATHINFO_EXTENSION) == '') {
        if (commerce_xls_import_get_error($row, $key) == '') {
          commerce_xls_import_set_error($row, $key, 'Entered image is missing extension');
        }
      }
      else {
        $file = file_load($image_info[trim($filename)]);
        if ($file !== FALSE) {
          $form_state['values'][$key][$language] = get_object_vars($file);
        }
        else {
          if (commerce_xls_import_get_error($row, $key) == '') {
            commerce_xls_import_set_error($row, $key, 'File could not be loaded');
          }
        }
      }
    }
  }
}

/**
 * Validates the product's sku.
 *
 * If the product does not have a sku, return false. If the sku is not a valid
 * commerce sku, return false. If the sku is already in use, return false.
 * Otherwise, return true.
 *
 * @param string $sku
 *   The sku of the variation being created.
 *
 * @return bool
 *   True if valid.
 */
function commerce_xls_import_validate_sku($row, $sku) {

  if ($sku == NULL) {
    // Sku doesn't exist, mark this product as an error.
    commerce_xls_import_set_error($row, 'sku', 'sku required');
    return FALSE;
  }

  // Validate sku. The 'a' is added because commerce_product_validate_sku()
  // returns a false positive if the first character of $sku is a ','
  $sku_is_valid = commerce_product_validate_sku('a' . $sku);

  if (!$sku_is_valid) {
    commerce_xls_import_set_error($row, 'sku', 'sku format invalid');
    return FALSE;
  }

  $sku_available = commerce_product_validate_sku_unique($sku, NULL);

  if (!$sku_available) {
    commerce_xls_import_set_error($row, 'sku', 'sku already in use');
    return FALSE;
  }

  return TRUE;
}

/**
 * Gets the text format to be used in the body of the product.
 *
 * @param object $user
 *  The user account object.
 *
 * @return string
 *  The text format selection for a given user if set, otherwise return the
 *  'plain_text' format option.
 */
function commerce_xls_import_get_text_format($user) {
  $formats = filter_formats($user);

  if (isset($formats['full_html'])) {
    return 'full_html';
  }
  elseif (isset($formats['filtered_html'])) {
    return 'filtered_html';
  }

  return 'plain_text';
}

/**
 * Creates the product.
 *
 * @param int $row
 *  Current row in spreadsheet.
 *
 * @param array $values
 *  Contains the possible field values of the product type.
 *
 * @param array $entity_info
 *  Contains the entity_info required to create product.
 *
 * @param string $product_type
 *  The product type for the product being created.
 *
 * @param array $image_info
 *  Contains image file information.
 *
 * @return int $nid|NULL
 *  If successful the nid of the newley created product, otherwise NULL.
 */
function commerce_xls_import_create_product($row, $values, $entity_info, $product_type, $display_type, $image_info = array()) {
  module_load_include('inc', 'node');
  module_load_include('inc', 'node', 'node.pages');

  global $user;
  $form_state = array();

  $sku = $entity_info['sku'];

  $node = new stdClass();

  $language = commerce_xls_import_validate_languages($entity_info['language']);

  if (!$language) {
    // Language  not there, set to undefined.
    $language = LANGUAGE_NONE;
  }
  $node->language = $language;
  $new_language = $language;
  $language = LANGUAGE_NONE;

  $text_format = commerce_xls_import_get_text_format($user);

  // Set up form state.
  $form_state['values']['title'] = $entity_info['title'];
  $form_state['values']['language'] = $language;
  $form_state['values']['name'] = $user->name;
  $form_state['values']['body'] = array(
    "$language" => array(
      0 => array(
        'value' => $entity_info['body'],
        'format' => $text_format,
      ),
    ),
  );
  $form_state['values']['status'] = 1;
  $form_state['values']['promote'] = 0;
  $form_state['values']['sticky'] = 0;
  $form_state['values']['op'] = t('Save');

  $values['language'] = $language;

  $nid = commerce_xls_import_validate_product($row, $entity_info);

  if ($nid === FALSE) {
    // Product failed validation.
    return FALSE;
  }
  elseif ($nid == NULL) {

    // Prepare node.
    $node->type = $display_type;
    node_object_prepare($node);
    $node->title = $entity_info['title'];
    $node->language = $new_language;

    $node->body = array(
      "$language" => array(
        0 => array(
          'value' => $entity_info['body'],
          'format' => 'full_html',
        ),
      ),
    );

    commerce_xls_import_update_entity_info($row, $node, $entity_info, $values, $image_info, TRUE);

    // Create the form_state to use node validation.
    foreach ($values as $key => $field) {
      $field_info = field_info_field($key);
      if ($field_info['type'] == 'image') {

        // Validate Images.
        commerce_xls_import_check_set_images($row, $field, $form_state, $image_info, $key, $language);
      }
      else {
        $form_state['values'][$key] = array(
          "$language" => array(
            0 => $field,
          ),
        );
      }
    }

    $form_state['values']['language'] = $language;
  }
  else {
    $node = node_load($nid, NULL, TRUE);
    $node->language = $new_language;
  }

  // Validate sku.
  commerce_xls_import_validate_sku($row, $sku);

  $product = commerce_product_new($product_type);
  $product->created = time();
  commerce_xls_import_update_entity_info($row, $product, $entity_info, $values, $image_info);

  if (CommerceXlsImportSettings::isImport() && !commerce_xls_import_get_row_error($row)) {
    // If no errors exist, save the variation and node.
    commerce_product_save($product);

    $node->field_product[LANGUAGE_NONE][]['product_id'] = $product->product_id;
    $node->language = $new_language;

    node_save($node);
    return $node->nid;
  }

  return NULL;
}

/**
 * Searches to see if the product if it already exists.
 *
 * If a product with the given title already exists, return its nid. If
 * multiple products with the given title exist, return an array containing
 * the nids of all matching products. Otherwise, if no products exist, return
 * null.
 *
 * @param string $title
 *   The title of the product to be queried.
 *
 * @return int|array|null
 *   Returns single nid if one product found.
 *   Returns array of nids if multiple products found.
 *   Returns null if no products found.
 */
function commerce_xls_import_search_for_product($title) {
  $nids = array();
  $count = 0;

  $result = db_select('node', 'n')
    ->fields('n', array('nid'))
    ->condition('n.title', $title, '=')
    ->execute();

  while ($record = $result->fetchAssoc()) {
    $nids[$count] = $record['nid'];
    $count++;
  }

  if ($count == 1) {
    return $nids[0];
  }
  elseif ($count > 1) {
    return $nids;
  }
  else {
    return NULL;
  }
}

/**
 * Gets an array of category terms.
 *
 * Function to use a comma separated list of category names to retrieve the
 * taxonomy terms.
 *
 * @param array $category_names
 *  List of category names.
 *
 * @return array
 *    An array containing category terms.
 */
function commerce_xls_import_get_category_id($category_names) {
  $term_list = explode(',', $category_names);
  $terms = array();

  foreach ($term_list as $term) {
    $tax_terms = taxonomy_get_term_by_name($term);
    foreach ($tax_terms as $tax_term) {
      $terms[]['tid'] = $tax_term->tid;
    }
  }

  return $terms;
}

/**
 * Updates the entity info.
 *
 * @param int $row
 *  Current row in spreadsheet.
 *
 * @param object $product
 *  A product object with all default fields initialized.
 *
 * @param array $entity_info
 *  Contains the entity info with fields to update on product object.
 *
 * @param array $values
 *  Contains the possible field values of the product type.
 *
 * @param array $image_info
 *  Contains image file information.
 *
 * @param boolean $a_node
 *  True if entity is a node and False if not a node.
 *
 */
function commerce_xls_import_update_entity_info($row, $product, $entity_info, $values, $image_info, $a_node = FALSE) {
  $language = $values['language'];

  if (!$a_node) {
    foreach ($entity_info as $key => $value) {
      $product->$key = $value;
    }

    $product->changed = time();
    $product->language = $language;
    if ($entity_info['variation_title'] != NULL) {
      $product->title = $entity_info['variation_title'];
    }
    else {
      $product->title = $entity_info['title'];
    }
  }

  // Check for added fields.
  foreach ($values as $key => $field) {
    if (strpos($key, 'field') === 0) {
      // it's an added field.
      $info = field_info_field($key);

      if ($info['type'] == 'image' && $image_info) {
        // This field contains an image
        // check for an apostrophe to see if multiple images.
        $filenames = array($field);
        if (strpos($field, ',')) {
          $filenames = explode(',', $field);
        }
        // Reset all the images to only use the ones provided.
        $product->{$key}[$language] = array();
        foreach ($filenames as $filename) {
          if ($filename == '') {
            // No image entered.
          }
          elseif (pathinfo($filename, PATHINFO_EXTENSION) == '') {
            if (commerce_xls_import_get_error($row, $key) == '') {
              commerce_xls_import_set_error($row, $key, 'Image is missing extension');
            }
          }
          else {
            $file = file_load($image_info[trim($filename)]);

            if ($file !== FALSE) {
              $product->{$key}[$language][] = get_object_vars($file);
              file_usage_add($file, 'commerce_xls_import', 'user', 1);
            }
            else {
              if (commerce_xls_import_get_error($row, $key) == '') {
                commerce_xls_import_set_error($row, $key, 'Invalid image data entered');
              }
            }
          }
        }
      }
      elseif ($info['type'] == 'entityreference') {
        // Get nid from given entity name.
        if ($field != '') {
          // Break them up since multiples are comma delimited.
          $entity_references = explode(',', $field);

          // Reset the references to avoid adding duplicates.
          $product->{$key} = NULL;

          foreach ($entity_references as $entity_reference) {
            $nid = commerce_xls_import_get_entity_reference_nid(trim($entity_reference));

            if ($nid) {
              $product->{$key}[$language][]['target_id'] = $nid;
            }
          }
        }
      }
      elseif ($info['type'] == 'commerce_price') {
        if ($field != '') {
          $price = array(
            "$language" => array(
              0 => array(
                'amount' => $field * 100,
                'currency_code' => $values['currency_code'],
              ),
            ),
          );
          $product->{$key} = $price;
        }
      }
      elseif ($info['type'] == 'list_boolean') {
        $product->$key = array(
          "$language" => array(
            0 => array(
              'value' => $field,
            ),
          ),
        );
      }
      elseif ($info['type'] == 'taxonomy_term_reference') {
        $terms = commerce_xls_import_get_category_id($field);
        $product->$key = array(
          "$language" => $terms,
        );
      }
      else {
        $product->$key = array(
          "$language" => array(
            0 => array(
              'value' => $field,
            ),
          ),
        );
      }
    }
  }
  if (!$a_node) {
    // Set the price and currency.
    if (commerce_xls_import_validate_price($row, $values)) {
      $price = array(
        "$language" => array(
          0 => array(
            'amount' => $values['commerce_price'] * 100,
            'currency_code' => $values['currency_code'],
          ),
        ),
      );
      $product->commerce_price = $price;
    }
  }
}

/**
 * Validates that the products price is a valid price.
 *
 * @param int $row
 *  Current row in the import spreadsheet.
 *
 * @param array $values
 *    An array containing the product values.
 *
 * @return bool
 *    False if no price entered or invalid price entered. Otherwise true.
 */
function commerce_xls_import_validate_price($row, array $values) {
  if (!isset($values['commerce_price']) || $values['commerce_price'] == NULL) {
    commerce_xls_import_set_error($row, 'commerce_price', 'No Price Entered');
    return FALSE;
  }

  if (!is_numeric($values['commerce_price'])) {
    commerce_xls_import_set_error($row, 'commerce_price', 'Invalid Price Entered');
    return FALSE;
  }

  return TRUE;
}

/**
 * Gets the entity reference nid.
 *
 * @param string $field
 *  The title of the entity reference.
 *
 * @return int
 *  The entity reference nid.
 */
function commerce_xls_import_get_entity_reference_nid($field) {
  $result = db_select('node', 'n')
    ->fields('n', array('nid'))
    ->condition('title', $field, 'like')
    ->execute();

  $data = $result->fetchAssoc();

  return $data['nid'];
}

/**
 * Get headers from XLS.
 *
 * @param object $phpexcel
 *  The phpexcel object created for the current excel spreasheet, passed by
 *  reference.
 *
 * @return array $headers
 *  The headers from the current excel spreadsheet.
 */
function commerce_xls_import_get_headers(&$phpexcel) {
  static $headers = NULL;

  if (!isset($headers)) {
    $headers = array();

    $last_column = $phpexcel->getHighestColumn();
    $headers_temp = $phpexcel->rangeToArray('A1:' . $last_column . '1', NULL, TRUE, TRUE, TRUE);
    $headers_temp = $headers_temp[1];
    foreach ($headers_temp as $key => $header) {
      // Use ascii to convert letter to number.
      // 66 is the offset.
      $numeric_key = ord($key) - 65;
      $headers[$numeric_key] = $header;
    }
  }

  return $headers;
}

/**
 * Handles the main zip extraction.
 *
 * @return array|bool
 *  Returns array of files names if zip extraction is successful, otherwise
 *  it return boolean value FALSE.
 */
function commerce_xls_import_extract_zip() {
  $dir = realpath('.') . '/' . variable_get('file_public_path', conf_path() . '/files');

  $import_successful = commerce_xls_import_unpack_zip($dir, 'product_images', $dir);

  // Add new files to the file table.
  if ($import_successful) {
    return commerce_xls_import_create_image_database_entries('public://');
  }
  else {
    return FALSE;
  }
}

/**
 * Adds the any images in the base path directory to the file table.
 *
 * @param string $base_path
 *   The base path where the file is located.
 *
 * @return array
 *   An array containing the filename and fid pairs.
 */
function commerce_xls_import_create_image_database_entries($base_path) {
  global $user;
  $results = array();

  $filenames = scandir($base_path);

  foreach ($filenames as $filename) {
    // Check file table for entry for this file, if an entry, ignore.
    if ($filename != '.' && $filename != '..' && !is_dir("$base_path/$filename")) {
      $uri = "$base_path/$filename";
      if ($fid = commerce_xls_import_file_entry_exists($uri)) {
        // File entry exists update it.
        $results[$filename] = $fid;
      }
      else {

        // doesn't exist, create file entry.
        $file = new stdClass();
        $file->uid = $user->uid;
        $file->filename = $filename;
        $file->uri = $uri;
        $file->filemime = mime_content_type($uri);
        $file->filesize = filesize($uri);
        $file->status = 1;

        $file = file_save($file);
        $results[$filename] = $file->fid;
      }
    }
  }

  return $results;
}

/**
 * Checks to see if file entry already exists.
 *
 * @param string uri
 *  The uri for the underlying file.
 *
 * @return int|bool
 *  If the uri is found return the fid, otherwise return false.
 */
function commerce_xls_import_file_entry_exists($uri) {
  $result = db_select('file_managed', 'f')
    ->fields('f', array('uri', 'fid'))
    ->condition('f.uri', $uri, '=')
    ->execute();

  while ($record = $result->fetchAssoc()) {
    return $record['fid'];
  }
  return FALSE;
}

/**
 * Base function for unpacking a zip.
 *
 * Uses the command line to unpack .zip files and move to public files
 * directory.
 *
 * @param string $zip_dir
 *  The directory name of the file to be unzipped.
 *
 * @param string $filename
 *  The name of the directory to place the unzipped files.
 *
 * @param string $save_dir
 *  The name of the directory to extract the files to.
 *
 * @return bool
 *  TRUE if file is zip file is succesfully extracted, othewise FALSE.
 */
function commerce_xls_import_unpack_zip($zip_dir, $filename, $save_dir) {
  $file = $zip_dir . '/' . $filename . '.zip';

  $zip = new ZipArchive;
  $resource = $zip->open($file);
  if ($resource === TRUE) {
    // extract it to the path we determined above
    $zip->extractTo($save_dir);
    $zip->close();

    drupal_set_message(t('@filename.zip extracted successfully to @save_dir', array('@filename' => $filename, '@save_dir' => $save_dir)));
    return TRUE;
  }
  else {
    drupal_set_message(t('There was an error extracting @filename.zip. Please try again, if the problem persists contact the system administrator', array('@filename' => $filename)), 'error');
    watchdog('commerce_xls_import', 'Error extracting zip file @filename', array('@filename' => $filename));
    return FALSE;
  }

}

/**
 * Gets any fields that may apply to the product and (optionally) their type.
 *
 * @param string $product_type
 *   The product type.
 * @param bool $get_field_type
 *   Whether or not to include field type.
 *
 * @return array
 *   If $get_field_type is FALSE returns an array of all possible product types.
 *   If $get_field_type is TRUE returns an array of all possible product types
 *   as well as their field type.
 */
function commerce_xls_import_get_possible_fields($product_type, $display_type, $get_field_type = FALSE) {
  $result = array();
  $fields = field_info_field_map();
  foreach ($fields as $key => $field) {

    if ((isset($field['bundles']['commerce_product']) && in_array($product_type, $field['bundles']['commerce_product']))
      || (isset($field['bundles']['node']) && in_array($display_type, $field['bundles']['node']))
    ) {
      // We don't want to include the product reference since the import will
      // take care of that for us.
      // Also don't want to include the field rating since it's based off user
      // comments and isn't something that can be set by a simple value.
      if ($key != 'field_product' && $key != 'field_rating' && $key != 'title_field') {
        if ($get_field_type) {
          $result[$key]['type'] = $field['type'];
        }
        else {
          $result[$key] = $key;
        }
      }
    }
  }
  return $result;
}

/**
 * Gets an array containing all product NIDs by the given type.
 *
 * @param string $product_type
 *   The product type.
 *
 * @return array
 *   An array containing the NIDs of the given product type.
 */
function commerce_xls_import_nids_of_type($product_type) {
  $products = array();

  $result = db_select('node', 'n')
    ->fields('n', array('nid'))
    ->condition('n.type', $product_type, '=')
    ->execute();
  $records = $result->fetchAllAssoc('nid');

  foreach ($records as $key => $record) {
    $products[] = $key;
  }

  return $products;
}

/**
 * Get the headers needed for the export and import template.
 *
 * @param int|bool $nid
 *  list of nodes ids.
 *
 * @param string $product_type
 *  The product type for the selected import.
 *
 * @return array $headers
 *
 */
function commerce_xls_import_generate_headers($nid = NULL, $product_type = NULL, $display_type = NULL) {
  $headers = array();

  $product = commerce_xls_import_get_possible_fields($product_type, $display_type);

  $headers['Products'][] = 'title';
  $headers['Products'][] = 'variation_title';
  $headers['Products'][] = 'sku';
  $headers['Products'] = array_merge($headers['Products'], array_keys($product));
  $headers['Products'][] = 'status';
  $headers['Products'][] = 'language';
  if (CommerceXlsImportSettings::isImport() && $nid != NULL) {
    $headers['Products'][] = 'nid';
  }

  return $headers;
}

/**
 * Exports an array containing data of all products of a given type.
 *
 * @param string $product_type
 *   The machine readable product type.
 *
 * @return array
 *   The data of all products of the given type.
 */
function commerce_xls_import_export_product_data($product_type, $display_type) {
  $nids = commerce_xls_import_nids_of_type($display_type);
  $products = array();
  $field_info = commerce_xls_import_get_possible_fields($product_type, $display_type, TRUE);

  $headers_list = commerce_xls_import_generate_headers(NULL, $product_type, $display_type);
  $headers = array();

  // Set up headers array to match exported data.
  foreach ($headers_list['Products'] as $header) {
    $headers[$header] = '';
  }

  foreach ($nids as $nid) {

    $product_display = node_load($nid);

    // The entity wrapper.
    $wrapper = entity_metadata_wrapper('node', $product_display);

    $product_title = $wrapper->title->value(array('sanitize' => FALSE));
    $product_language = $wrapper->language->value(array('sanitize' => FALSE));
    $product_body = $wrapper->body->value(array('sanitize' => FALSE));

    // Array containing variation data.
    $variations = $wrapper->field_product->value(array('sanitize' => FALSE));

    //if field_product is a 1:1 field it will return the object and not an array
    if(!is_array($variations)) {
      $variations = array($variations);
    }

    foreach ($variations as $variation) {
      $data = array();
      $data['title'] = $product_title;
      $data['body'] = $product_body['value'];
      $data['language'] = $product_language;
      $data['variation_title'] = $variation->title;
      $data['sku'] = $variation->sku;
      $data['status'] = $variation->status;

      foreach ($field_info as $key => $field) {
        switch ($field['type']) {
          case 'commerce_price':
            $price = $variation->$key;
            $data[$key] = $price[$product_language][0]['amount'];
            break;

          case 'image':
            $filenames = '';
            $images = $variation->$key;

            if (!empty($images)) {
              $images = $images[$product_language];
              foreach ($images as $image) {
                $filenames = $filenames . $image['filename'] . ', ';
              }
              $filenames = substr($filenames, 0, -2);
            }

            $data[$key] = $filenames;
            break;

          case 'taxonomy_term_reference':
            $name = '';
            if (!empty($variation->$key)) {
              $term_reference = $variation->$key;
              $tid = $term_reference[$product_language][0]['tid'];
              $term = taxonomy_term_load($tid);
              $name = $term->name;
            }
            else {
              // Is a field from the product, not the variation.
              if (isset($wrapper->$key)) {
                $term_reference = $wrapper->$key->value(array('sanitize' => TRUE));
                if (!empty($term_reference)) {
                  $name = $term_reference->name;
                }
              }
            }
            $data[$key] = $name;
            break;

        }
      }

      // Put keys in proper order for export.
      $data = array_merge($headers, $data);

      $products[] = $data;
    }

  }
  
  return $products;
}

/**
 * Gets the owner of the form field.
 *
 * @param string $field_name
 *  The field name to check ownwership against.
 *
 * @return string
 *  The owner of the given field
 *
 */
function commerce_xls_import_get_field_owner($field_name) {
  if ($field_name == 'title') {
    return 'parent';
  }
  elseif ($field_name == 'variation_title') {
    return 'variation';
  }
  elseif ($field_name == 'sku') {
    return 'variation';
  }
  elseif ($field_name == 'status') {
    return 'both';
  }
  elseif ($field_name == 'language') {
    return 'parent';
  }
  else {
    $field_info = field_info_field($field_name);
    if (isset($field_info['bundles']['commerce_product'])) {
      if (isset($field_info['bundles']['node'])) {
        return 'both';
      }
      else {
        return 'variation';
      }
    }
    else {
      return 'parent';
    }
  }
}

/**
 * Checks the status of the current import.
 */
function commerce_xls_import_current_status() {
  $current = variable_get('commerce_xls_import_import_count_status', '');

  $is_running = commerce_xls_import_is_running();

  if (($current == '' && $is_running)) {
    $message = t('Working...');
    $status = 0;
  }
  elseif ($current == '' && !$is_running) {
    $message = t('Done');
    $status = 1;
    variable_set('commerce_xls_import_completed', 1);
  }
  else {
    $message = t('Status : @current/@total products evaluated with @errors errors',
      array(
        '@current' => $current['completed'],
        '@total' => $current['total'],
        '@errors' => variable_get('commerce_xls_import_error_count'),
      ));
    $message .= '<br /><progress id="commerce-xls-import-progress" value=' . $current['completed'] . ' max=' . $current['total'] . ' style="clear:both"></progress>';
    $status = 0;
  }

  if ($current == '') {
    $output = array(
      'completed' => 0,
      'total' => 0,
      'message' => $message,
      'status' => $status,
    );
  }
  else {
    $output = array(
      'completed' => $current['completed'],
      'total' => $current['total'],
      'message' => $message,
      'status' => $status,
    );
  }

  drupal_json_output($output);
}
