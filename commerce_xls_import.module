<?php
/**
 * @file
 * Imports Drupal Commerce Entities from an XLS file.
 *
 * Returns an XLS file highlighting success and failures.
 */

define('COMMERCE_XLS_IMPORT_DATA_ERROR', 0);
define('COMMERCE_XLS_IMPORT_DATA_SUCCESS', 1);
define('COMMERCE_XLS_IMPORT_DATA_WARNING', 2);
define('COMMERCE_XLS_IMPORT_DATA_NONE', 3);

/**
 * Implements hook_menu().
 *
 * Adds menu items to generate the headers or begin the commerce XLS import.
 */
function commerce_xls_import_menu() {
  $items = array();

  $items['admin/commerce/products/import_commerce'] = array(
    'title' => 'Commerce Import',
    'description' => 'Import commerce XLS or generate XLS headers form',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_xls_import_settings'),
    'access arguments' => array('administer commerce import'),
    'file' => NULL,
    'type' => MENU_LOCAL_TASK,
  );

  $items['admin/commerce/products/import_commerce/get_import_status'] = array(
    'title' => 'Commerce Import Status Update',
    'description' => 'Update the status of the current commerce xls import',
    'page callback' => 'commerce_xls_import_current_status',
    'access arguments' => array('administer commerce import'),
    'file' => NULL,
  );

  return $items;
}

//@TODO - _settings probably isn't the best name for this form, settings usually means the module settings, not a user form.
/**
 * Import Menu Form.
 *
 * Just contains the buttons to begin the import or to generate example headers.
 */
function commerce_xls_import_settings() {
  $form = array();
  $types = array();

  if (variable_get('import_completed', '') == 1) {
    drupal_set_message(t('Import Complete'));
    variable_del('import_completed');
  }

  $form['message'] = array(
    '#markup' => '<div id="import_status_messages" class="messages status" style="display:none;"></div>',
  );

  $form['legend'] = array(
    '#type' => 'fieldset',
    '#title' => t('Instructions'),
    '#collapsed' => TRUE,
    '#collapsible' => TRUE,
    '#weight' => 0,
  );

  // Get the drupal commerce product types.
  $query = db_select('field_data_field_product', 'fdfp')
    ->fields('fdfp', array("bundle"))
    ->distinct();

  $result = $query->execute();

  while ($record = $result->fetchAssoc()) {
    $types[] = $record['bundle'];

    $form[$record['bundle']] = array(
      '#type' => 'markup',
      '#prefix' => '<div class="product-options ' . $record['bundle'] . '">',
      '#suffix' => '</div><div style="clear:both" class="divider"></div>',
    );

    $form[$record['bundle']]['template-' . $record['bundle']] = array(
      '#type' => 'submit',
      '#value' => t('Download !product_type Template', array('!product_type' => $record['bundle'])),
      '#description' => t('Download a template for !product_type products', array('!product_type' => $record['bundle'])),
      '#attributes' => array('product_type' => $record['bundle']),
    );
    $form[$record['bundle']][$record['bundle']] = array(
      '#type' => 'file',
      '#title' => t('Upload !product_type Import File', array('!product_type' => $record['bundle'])),
      '#description' => t('Upload the .xls file that contains any !product_type products to add to the catalogue', array('!product_type' => $record['bundle'])),
      '#attributes' => array('product_type' => $record['bundle']),
    );

  }

  $last_import = variable_get('commerce_xls_import_last_import', '');
  if ($last_import != '') {
    $last_import_message = '<h6>' . t('Last Import Completed: !time', array('!time' => date('F j, Y - h:i T', $last_import['completed']))) . '</h6>';
    $last_import_message .= t('!row/!total products evaluated during last import', array('!row' => $last_import['row'], '!total' => $last_import['total']));
  }
  else {
    $last_import_message = '';
  }

  $form['buttons'] = array(
    '#type' => 'markup',
    '#prefix' => '<div style="clear:both"></div><div class="import-buttons">',
    '#suffix' => '</div>',
    '#weight' => 10,
  );

  if (!commerce_xls_import_is_running()) {
    $form['last-import-message'] = array(
      '#markup' => '<div class="last-import-message">' . $last_import_message . '</div>',
      '#weight' => 9,
    );

    $form['buttons']['import_button'] = array(
      '#type' => 'submit',
      '#value' => t('Begin Full Import'),
    );
    $form['import_status'] = array(
      '#type' => 'hidden',
      '#value' => 0,
    );
  }
  else {
    $form['last-import-message'] = array(
      '#markup' => '<div class="last-import-message"><h6>' . t('Import in progress') . '</h6></div>',
      '#weight' => 9,
    );
    $form['buttons']['import_stop'] = array(
      '#type' => 'submit',
      '#value' => t('Stop Import'),
    );

    $form['import_status'] = array(
      '#type' => 'hidden',
      '#value' => 1,
    );
    drupal_set_message(t('You are currently running an import, you will not be able to run another until it is finished or stopped manually'), 'warning', FALSE);
  }

  $form['buttons']['errors_button'] = array(
    '#type' => 'submit',
    '#value' => t('Retrieve Latest Import Results'),
  );

  // @TODO - not critical but we could probably move a whole bunch of this formatting stuff into some templates called through theme functions, all this markup screams template
  // https://www.drupal.org/node/715160
  $description = "<h3>" . t('Commerce Import') . "</h2>";
  $description .= "<h5>" . t('Instructions') . "</h5>";
  $description .= "<p>" . t('There are 2 main functions for the Commerce Import, which are:') . "</p>";
  $description .= "<ul>";
  $description .= "<li>" . t('Import Products') . "</li>";
  $description .= "<li>" . t('Generate Product Templates') . "</li>";
  $description .= "</ul>";
  $description .= "<p>" . t("Using the product templates, a list of products to add may be uploaded using the appropriate file upload section which will then be added to the commerce catalogue. Use the legend below to figure out which fields belong to the base product, or each variation.") . "</p>";
  $description .= "<p>" . t("When an import is complete, a result document will be generated to show how the import went. If the product was imported successfully, the line will be marked green. If the product had an error, the bad fields will be marked red and the product will not be created, nor will it's variations. If a variation has an error, the field will be marked red.") . "</p>";
  $description .= "<p>" . t("If you find an error and wish to change that product in question, make your changes in the error document and submit it using the regular import functionality. This will update all the products in the file and not create new ones.") . "</p>";

  $form['legend']['description'] = array(
    '#markup' => $description,
  );

  $image_instructions = "";
  $image_instructions .= "<h5 id='image-description'>" . t("Image Instructions") . "</h5>";
  $image_instructions .= "<p>" . t('Images may be uploaded through ftp by creating a .zip file that contains the necessary images to the /import_images directory named !strongproduct_images.zip!endstrong. Full path : sites/default/files/import_images/product_images.zip', array('!strong' => '<strong>', '!endstrong' => '</strong>')) . "</p>";

  $form['legend']['images-text'] = array(
    '#markup' => $image_instructions,
  );

  $form['legend']['parent'] = array(
    '#markup' => '<div id="legend-swatches"><div class="excel-swatches swatch-container" ><h6>' . t('Field Colors') . '</h6><div id="parent-swatch" ><div class="swatch"><span>' . t('Parent product') . '</span></div><span>' . t('The fields necessary to create a base product') . '</span></div>',
  );
  $form['legend']['variation'] = array(
    '#markup' => '<div id="variation-swatch"><div class="swatch"><span>' . t('Variation') . '</span></div><span>' . t('The fields that need to be filled out to successfully create a product variation') . '</span></div>',
  );

  $form['legend']['both'] = array(
    '#markup' => '<div id="both-swatch"><div class="swatch">' . t('Parent and variation') . '</span></div><span>' . t('The fields required by both  base product and its variations') . '</span></div></div>',
  );

  $form['legend']['result_colors'] = array(
    '#markup' => '<div class="result-swatches swatch-container" ><h6>' . t('Result Colors') . '</h6>',
  );

  $form['legend']['warning'] = array(
    '#markup' => '<div id="warning-swatch"><div class="swatch"><span>' . t('Warning') . '</span></div><span>' . t("A field highlighted in this color may have something wrong with it, or it hasn't been evaluated") . '</span></div>',
  );
  $form['legend']['error'] = array(
    '#markup' => '<div id="error-swatch"><div  class="swatch"><span>' . t('Error') . '</span></div><span>' . t('A field in this color has had some errors found') . '</span></div>',
  );
  $form['legend']['success'] = array(
    '#markup' => '<div id="success-swatch"><div  class="swatch"><span>' . t('Successfull') . '</span></div><span>' . t('A field in highlighted in this color is correct') . '</span></div></div></div>',
  );

  $form['legend']['field-legend'] = array(
    '#type' => 'fieldset',
    '#title' => t('Field Help'),
    '#collapsed' => TRUE,
    '#collapsible' => TRUE,
    '#prefix' => '<div style="clear:both"></div>',
  );

  $form['legend']['field-legend']['product_title'] = array(
    '#markup' => '<div class="product-field"><h6>' . t('title') . '</h6><span class="product-field-description">' . t('The title of the base product you are creating') . '</span></div><div style="clear:both;"></div>',
  );

  $form['legend']['field-legend']['sku'] = array(
    '#markup' => '<div class="product-field"><h6>' . t('sku') . '</h6><span class="product-field-description">' . t('The sku of the product variation you are creating') . '</span></div><div style="clear:both;"></div>',
  );

  $form['legend']['field-legend']['status'] = array(
    '#markup' => '<div class="product-field"><h6>' . t('status') . '</h6><span class="product-field-description">' . t('The status of the product or variation. 1 if the item is active, 0 if inactive') . '</span></div><div style="clear:both;"></div>',
  );

  $form['legend']['field-legend']['language'] = array(
    '#markup' => '<div class="product-field"><h6>' . t('language') . '</h6><span class="product-field-description">' . t('The language short hand to create the product in. (en, fr etc)') . '</span></div><div style="clear:both;"></div>',
  );

  foreach ($types as $product) {
    $fields = commerce_xls_import_get_possible_fields($product);
    foreach ($fields as $field) {
      $info = field_info_instance('node', $field, $product);

      if (isset($info['description']) && $info['description'] != NULL) {
        // Only display description if it exists.
        $form['legend']['field-legend'][$product][$field] = array(
          '#markup' => '<div class="product-field"><h6>' . $field . '</h6><span class="product-field-description">' . $info['description'] . '</span></div><div style="clear:both;"></div>',
        );
      }
    }
  }

  $form['legend']['field-legend']['variation_title'] = array(
    '#markup' => '<div class="product-field"><h6>' . 'Variation Title' . '</h6><span class="product-field-description">' . t('The title of the variation of the product you are creating. If left blank it will use the title of the base product.') . '</span></div><div style="clear:both;"></div>',
  );

  $form['#submit'][] = 'commerce_xls_import_settings_submit';

  return $form;
}

/**
 * Hook_perm().
 */
function commerce_xls_import_permission() {
  return array(
    'administer commerce import' => array(
      'title' => t('Administer Commerce XLS Import'),
      'description' => t('Perform an XLS import'),
    ),
  );
}

/**
 * Determines whether an import is currently running in the background.
 *
 * Returns True if one is running, otherwise false.
 */
function commerce_xls_import_is_running() {
  $result = db_select('background_process', 'bp')
    ->fields('bp', array('callback', 'exec_status'))
    ->condition('callback', '%commerce_xls_import_import%', 'LIKE')
    ->execute();

  if ($result->rowCount()) {
    return TRUE;
  }

  return FALSE;
}

//@TODO - move these to be next to the form declaration, usually goes form, form_validate, form_submit
/**
 * Validates the settings.
 */
function commerce_xls_import_settings_validate($form, &$form_state) {

  if (isset($_FILES['files'])) {
    foreach ($_FILES['files']['tmp_name'] as $field_name => $value) {
      if ($value != NULL && is_uploaded_file($_FILES['files']['tmp_name'][$field_name])) {
        $file = file_save_upload($field_name);
        if ($file) {
          $form_state['files'][] = array('uri' => $file->uri, 'product_type' => $field_name);
        }
      }
    }
  }

  if (!isset($form_state['files']) && ($form_state['clicked_button']['#id'] == 'edit-import-button')) {
    foreach ($_FILES['files']['tmp_name'] as $field_name) {
      form_set_error($field_name, t('No files to import'));
    }
  }
}

/**
 * Submit handler for the import menu section.
 */
function commerce_xls_import_settings_submit($form, &$form_state) {
  global $user;

  if ($form_state['clicked_button']['#id'] == 'edit-import-button') {
    // Reset import table.
    //@TODO - confirm there isn't currently an import running, this may need to be moved to the background process code instead?

    foreach ($form_state['files'] as $file) {
      if (!commerce_xls_import_is_running()) {
        $handle = background_process_start('commerce_xls_import_import', $file);

        db_insert('commerce_xls_imports')
          ->fields(array(
            'status' => 'pending',
            'handle' => $handle,
            'uid' => $user->uid,
          ))
          ->execute();
      }
      else {
        drupal_set_message(t('You are already running an import. Please wait until it is finished or cancel the current one'), 'error', FALSE);
      }
    }
  }
  elseif ($form_state['clicked_button']['#id'] == 'edit-zip-button') {
    commerce_xls_import_extract_zip();
  }
  elseif ($form_state['clicked_button']['#id'] == 'edit-import-stop') {
    if (commerce_xls_import_stop_import()) {
      drupal_set_message(t('Import stopping at next parent product'), 'status', FALSE);
    }
    else {
      drupal_set_message(t('Failed to Stop Import'), 'error', FALSE);
    }
    drupal_goto('admin/commerce/products/import_commerce');
  }
  elseif ($form_state['clicked_button']['#id'] == 'edit-errors-button') {

    $path = realpath(".") . "/" . variable_get('file_public_path', conf_path() . '/files');
    $filename = "product_import_results.xls";

    if (is_readable("$path/$filename")) {
      header('Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
      header('Content-Disposition: attachment;filename="' . $filename . '"');
      header('Cache-Control: max-age=0');
      readfile("$path/$filename");

      // Exit is used to keep page from refreshing which would prevent download.
      exit;
    }
    else {
      drupal_set_message(t('No results found'), 'error');
    }
  }
  else {
    // it's something from an individual product type template download.
    $product_type = $form_state['clicked_button']['#attributes']['product_type'];

    commerce_xls_import_export('template', NULL, $product_type);

    $path = realpath(".") . "/" . variable_get('file_public_path', conf_path() . '/files');
    $filename = $product_type . "_template.xls";
    readfile("$path/$filename");

    // Exit is used to keep page from refreshing which would prevent download.
    exit;
  }
}

/**
 * Stops current import.
 */
function commerce_xls_import_stop_import() {
  // Set all updates to stopped status.
  $result = db_update('commerce_xls_imports')
    ->fields(array(
      'status' => 'stopped',
    ))
    ->execute();

  if ($result) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Main function for the drupal commerce XLS export.
 */
function commerce_xls_import_export($op, $product_info = NULL, $product_type = NULL, $nids = FALSE) {
  module_load_include('inc', 'phpexcel');
  // NOTE: This is required because the phpexcel module gives strict warnings
  // with its export functionality.
  error_reporting(E_ALL ^ E_STRICT);

  $data = array('Products' => array());

  $path = realpath(".") . "/" . variable_get('file_public_path', conf_path() . '/files');

  $headers = commerce_xls_import_generate_headers($nids, $product_type);
  $options = array('format' => 'xls', 'title' => t('Product Import Template'));

  if ($product_info == NULL || $op == 'template') {
    $data['Products'][] = array();
  }
  else {
    $mapped = FALSE;

    $count = 1;
    foreach ($product_info[0] as $row) {
      $count++;
      $new_data_array = array();

      if ($mapped) {
        foreach ($row as $key => $new) {
          $new_data_array[] = $new;
        }
      }
      else {
        foreach ($row as $key => $new) {
          $new_data_array[] = $new;
        }
        $mapped = TRUE;
      }

      if ($nids || commerce_xls_import_get_row_error($count)) {
        $array_pos = count($new_data_array) - 1;

        if ($headers['Products'][$array_pos] == 'nid') {
          if (commerce_xls_import_get_row_error($count)) {
            $new_data_array[$array_pos] = commerce_xls_import_get_row_error($count);
          }
          else {
            $new_data_array[$array_pos] = "";
          }
        }
        else {
          if (commerce_xls_import_get_row_error($count)) {
            $new_data_array[] = commerce_xls_import_get_row_error($count);
          }
          else {
            $new_data_array[] = "";
          }
        }
      }

      $data['Products'][] = $new_data_array;
    }
  }

  switch ($op) {
    case 'errors':
      if (!commerce_xls_import_generate_errors_xls($options, $path, $headers, $data)) {
        // If error, refresh page to display error.
        drupal_goto("admin/commerce/products/import_commerce");
      }

      break;

    case 'template':
      if (!commerce_xls_import_generate_template_xls($path, $product_type, $headers, $data, $options)) {
        // If error, refresh page to display error.
        drupal_goto("admin/commerce/products/import_commerce");
      }

      break;
  }
}

/**
 * Generate template xls.
 *
 * @return bool
 *    Returns TRUE upon success and False upon failure.
 */
function commerce_xls_import_generate_template_xls($path, $product_type, $headers, $data, $options) {
  $filename = $product_type . "_template.xls";
  $result = phpexcel_export($headers, $data, "$path/$filename", $options);

  if ($result == PHPEXCEL_SUCCESS) {
    header('Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    header('Content-Disposition: attachment;filename="' . $filename . '"');
    header('Cache-Control: max-age=0');

    return TRUE;
  }
  else {
    drupal_set_message(t('PHPExcel error @result', array('@result' => $result)), 'error');
    drupal_set_message(t('There was an error generating the template. If this persists, contact the system administrator'), 'error');

    return FALSE;
  }
}

/**
 * Generate product_import_results.xls.
 *
 * @return bool
 *    Returns TRUE upon success and False upon failure.
 */
function commerce_xls_import_generate_errors_xls($options, $path, $headers, $data) {
  $filename = "product_import_results.xls";
  $options['errors'] = TRUE;

  if (file_exists("$path/$filename")) {
    $command = "rm $path/$filename 2>&1";
    exec($command);
  }

  $result = phpexcel_export($headers, $data, "$path/$filename", $options);

  if ($result == PHPEXCEL_SUCCESS) {
    header('Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    header('Content-Disposition: attachment;filename="' . $filename . '"');
    header('Cache-Control: max-age=0');

    return TRUE;
  }
  else {
    drupal_set_message(t('PHPExcel error @result', array('@result' => $result)), 'error');
    drupal_set_message(t('There was an error generating the import result document. Please try again. If this problem persists, contact the system administrator'), 'error');

    return FALSE;
  }
}

/**
 * Main function for the drupal commerce XLS import.
 *
 * Extracts product_images.zip, then imports XLS file. If the XLS import is
 * successful the results will then be processed and the import will be started.
 *
 * @param null|array $file
 *   The XLS file info array containing product data to be imported.
 */
function commerce_xls_import_import(array $file = NULL) {
  module_load_include('inc', 'phpexcel', 'phpexcel');

  // Get the product type.
  $product_type = $file['product_type'];

  // Extract product images.
  $images_info = commerce_xls_import_extract_zip();

  // Import XLS.
  $result = phpexcel_import($file['uri']);

  // If an array, import function was successful.
  if (is_array($result)) {
    if (count($result) > 0) {
      $row = 1;
      foreach ($result as $sheet) {
        foreach ($sheet as $product) {
          $row++;

          // Set the import completion status.
          variable_set('commerce_xls_import_import_count_status', array('completed' => $row - 1, 'total' => count($sheet)));

          if ($product['title'] == NULL) {
            commerce_xls_import_set_error($row, 'title', "Product doesn't have a title");

            $has_errors = TRUE;
          }
          else {
            $has_errors = FALSE;
          }

          if (!$has_errors) {
            $values = commerce_xls_import_get_product_values($product, $product_type);
            if (!isset($product['nid']) || $product['nid'] == NULL) {
              // If nid is set it is a line from a resubmitted results.xls.
              $entity_info = commerce_xls_import_set_entity_values($product);
              commerce_xls_import_create_product($row, $values, $entity_info, $product_type, $images_info);
            }
            else {
              // If nid isn't null ignore it as it was already imported.
              commerce_xls_import_set_error($row, 'nid', 'nis was already imported');
            }
          }
        }
      }
    }

    $import_counts = variable_get('commerce_xls_import_import_count_status', '');
    variable_set('commerce_xls_import_last_import', array(
      'completed' => time(),
      'row' => $import_counts['completed'],
      'total' => $import_counts['total'],
    ));
    variable_del('commerce_xls_import_import_count_status');
    commerce_xls_import_export('errors', $result, $product_type, TRUE);
  }
  else {
    drupal_set_message(t("There was an error with the import, please try again. If this problem persists contact the system administrator"), "error");
  }
}

/**
 * Sets entity values.
 *
 * @param array $product
 *   The product array the entity is being created from.
 *
 * @return array
 *   An array containing all of the set entity values for the product.
 */
function commerce_xls_import_set_entity_values(array $product) {
  global $user;

  $entity_info = array(
    'status' => isset($product['status']) ? $product['status'] : NULL,
    'uid' => $user->uid,
    'sku' => isset($product['sku']) ? $product['sku'] : NULL,
    'title' => isset($product['title']) ? $product['title'] : NULL,
    'variation_title' => isset($product['variation_title']) ? $product['variation_title'] : (isset($product['title']) ? $product['title'] : NULL),
    'language' => isset($product['language']) ? $product['language'] : NULL,
    'categories' => isset($product['field_product_category']) ? $product['field_product_category'] : NULL,
    'body' => isset($product['body']) ? $product['body'] : NULL,
    'nid' => isset($product['nid']) ? $product['nid'] : NULL,
  );

  return $entity_info;
}

/**
 * Gets an array containing the set values of the product.
 *
 * Gets the field data from the product type and then creates an array that
 * contains the set data from the given product.
 *
 * @param array $product
 *   Product to be imported.
 * @param string $product_type
 *   The product type.
 *
 * @return array
 *   Returns the set values that correspond to the possible fields of the
 *   product type.
 */
function commerce_xls_import_get_product_values(array $product, $product_type) {
  $values = array(
    'currency_code' => commerce_default_currency(),
  );

  $possible_fields = commerce_xls_import_get_possible_fields($product_type);

  foreach ($possible_fields as $field) {
    $values[$field] = $product[$field];
  }

  return $values;
}

/**
 * Checks to see if the language table exists.
 *
 * If it does then it checks the languages table for a corresponding language.
 *
 * Returns the language if a match is found, false if the table does not
 * exist or no language match found.
 */
function commerce_xls_import_validate_languages($language) {
  if (db_table_exists('languages')) {
    $result = db_select('languages', 'l')
      ->fields('l', array('language', 'name'))
      ->execute();
    while ($record = $result->fetchAssoc()) {
      if ((strtolower($record['language']) == strtolower($language)) || strtolower($language) == strtolower($record['name'])) {
        return $record['language'];
      }
    }
  }

  return FALSE;
}

/**
 * Validates the product by title and returns nid if it exists.
 *
 * If one or no products with the same name exists, return nid. Otherwise
 * return false.
 *
 * @return bool
 *    True if product is valid.
 */
function commerce_xls_import_validate_product($row, $entity_info) {
  $nid = NULL;

  if (!isset($entity_info['nid']) || $entity_info['nid'] == NULL) {
    $nid = commerce_xls_import_search_for_product($entity_info['title']);
  }
  else {
    $nid = $entity_info['nid'];
  }

  // Validate nid.
  if (is_array($nid)) {
    // Multiple possible nid's mark warning and do not proceed any further.
    commerce_xls_import_set_error($row, 'nid', COMMERCE_XLS_IMPORT_DATA_WARNING, "Multiple product matches found");

    return FALSE;
  }

  return $nid;
}

/**
 * Checks image validity and sets it in the form_state if valid.
 */
function commerce_xls_import_check_set_images($row, $field, &$form_state, $image_info, $key, $language) {
  // it's an image, check whether multiple uploads.
  $filenames = array($field);
  if (strpos($field, ',')) {
    $filenames = explode(',', $field);
  }

  foreach ($filenames as $filename) {
    if ($filename != "") {
      if (pathinfo($filename, PATHINFO_EXTENSION) == "") {
        commerce_xls_import_set_error($row, $key, "Entered image is missing extension");
      }
      else {
        $file = file_load($image_info[trim($filename)]);
        if ($file !== FALSE) {
          $form_state['values'][$key][$language] = get_object_vars($file);
        }
        else {
          commerce_xls_import_set_error($row, $key, "File could not be loaded");
        }
      }
    }
  }
}

/**
 * Validates the product's sku.
 *
 * If the product does not have a sku, return false. If the sku is not a valid
 * commerce sku, return false. If the sku is already in use, return false.
 * Otherwise, return true.
 *
 * @param string $sku
 *   The sku of the variation being created.
 *
 * @return bool
 *   True if valid.
 */
function commerce_xls_import_validate_sku($row, $sku) {

  if ($sku == NULL) {
    // Sku doesn't exist, mark this product as an error.
    commerce_xls_import_set_error($row, 'sku', "sku required");
    return FALSE;
  }

  // Validate sku. The "a" is added because commerce_product_validate_sku()
  // returns a false positive if the first character of $sku is a ','
  $sku_is_valid = commerce_product_validate_sku("a" . $sku);

  if (!$sku_is_valid) {
    commerce_xls_import_set_error($row, 'sku', "sku format invalid");
    return FALSE;
  }

  $sku_available = commerce_product_validate_sku_unique($sku, NULL);

  if (!$sku_available) {
    commerce_xls_import_set_error($row, 'sku', "sku already in use");
    return FALSE;
  }

  return TRUE;
}

/**
 * Creates the product.
 */
function commerce_xls_import_create_product($row, $values, $entity_info, $product_type, $image_info = array()) {
  module_load_include('inc', 'node');
  module_load_include('inc', 'node', 'node.pages');

  global $user;
  $form_state = array();

  $sku = $entity_info['sku'];
  $node = new stdClass();

  $language = commerce_xls_import_validate_languages($entity_info['language']);

  if (!$language) {
    // language  not there, set to undefined.
    $language = LANGUAGE_NONE;
  }
  $node->language = $language;
  $new_language = $language;
  $language = LANGUAGE_NONE;

  // Set up form state.
  $form_state['values']['title'] = $entity_info['title'];
  $form_state['values']['language'] = $language;
  $form_state['values']['name'] = $user->name;
  $form_state['values']['body'] = array(
    "$language" => array(
      0 => array(
        'value' => $entity_info["body"],
        'format' => 'full_html',
      ),
    ),
  );
  $form_state['values']['status'] = 1;
  $form_state['values']['promote'] = 0;
  $form_state['values']['sticky'] = 0;
  $form_state['values']['op'] = t('Save');

  $values['language'] = $language;

  $nid = commerce_xls_import_validate_product($row, $entity_info);

  if ($nid === FALSE) {
    // Product failed validation.
    return FALSE;
  }
  elseif ($nid == NULL) {

    // Prepare node.
    $node->type = $product_type;
    node_object_prepare($node);
    $node->title = $entity_info['title'];
    $node->language = $new_language;

    $node->body = array(
      "$language" => array(
        0 => array(
          'value' => $entity_info["body"],
          'format' => 'full_html',
        ),
      ),
    );

    commerce_xls_import_update_entity_info($node, $entity_info, $values, $image_info, TRUE);

    // Create the form_state to use node validation.
    foreach ($values as $key => $field) {
      $field_info = field_info_field($key);
      if ($field_info['type'] == 'image') {

        // Validate Images.
        commerce_xls_import_check_set_images($row, $field, $form_state, $image_info, $key, $language);
      }
      else {
        $form_state['values'][$key] = array(
          "$language" => array(
            0 => $field,
          ),
        );
      }
    }

    $form_state['values']['language'] = $language;
  }
  else {
    $node = node_load($nid, NULL, TRUE);
    $node->language = $new_language;
  }

  // Validate sku.
  commerce_xls_import_validate_sku($row, $sku);

  $product = commerce_product_new($product_type);
  $product->created = time();
  commerce_xls_import_update_entity_info($row, $product, $entity_info, $values, $image_info);

  if (!commerce_xls_import_get_row_error($row)) {
    // If no errors exist, save the product.
    commerce_product_save($product);
  }
  else {
    // Don't create product or variation if there are errors.
    watchdog('commerce_xls_import', $entity_info['title'] . " has errors and will not be created");
    return FALSE;
  }

  $node->field_product[LANGUAGE_NONE][]['product_id'] = $product->product_id;

  if (!commerce_xls_import_get_row_error($row)) {
    // If no errors exist, save node.
    $node->language = $new_language;
    node_save($node);

    return $node->nid;
  }
  else {
    // Don't save node if errors exist.
    watchdog('commerce_xls_import', $entity_info['title'] . " has errors and will not be created");
    return FALSE;
  }
}

/**
 * Searches to see if the product if it already exists.
 *
 * If a product with the given title already exists, return its nid. If
 * multiple products with the given title exist, return an array containing
 * the nids of all matching products. Otherwise, if no products exist, return
 * null.
 *
 * @param string $title
 *   The title of the product to be queried.
 *
 * @return int|array|null
 *   Returns single nid if one product found.
 *   Returns array of nids if multiple products found.
 *   Returns null if no products found.
 */
function commerce_xls_import_search_for_product($title) {
  $nids = array();
  $count = 0;

  $result = db_select('node', 'n')
    ->fields('n', array('nid'))
    ->condition('n.title', $title, '=')
    ->execute();

  while ($record = $result->fetchAssoc()) {
    $nids[$count] = $record['nid'];
    $count++;
  }

  if ($count == 1) {
    return $nids[0];
  }
  elseif ($count > 1) {
    return $nids;
  }
  else {
    return NULL;
  }
}

/**
 * Gets an array of category terms.
 *
 * Function to use a comma separated list of category names to retrieve the
 * taxonomy terms.
 *
 * @return array
 *    An array containing category terms.
 */
function commerce_xls_import_get_category_id($category_names) {
  $term_list = explode(',', $category_names);
  $terms = array();

  foreach ($term_list as $term) {
    $tax_terms = taxonomy_get_term_by_name($term);
    foreach ($tax_terms as $term) {
      $terms[]['tid'] = $term->tid;
    }
  }

  return $terms;
}

/**
 * Updates the entity info.
 */
function commerce_xls_import_update_entity_info($row, $product, $entity_info, $values, $image_info, $a_node = FALSE) {
  $language = $values['language'];

  if (!$a_node) {
    foreach ($entity_info as $key => $value) {
      $product->$key = $value;
    }

    $product->changed = time();
    $product->language = $language;
    if ($entity_info['variation_title'] != NULL) {
      $product->title = $entity_info['variation_title'];
    }
    else {
      $product->title = $entity_info['title'];
    }
  }

  // Check for added fields.
  foreach ($values as $key => $field) {
    if (strpos($key, "field") === 0) {
      // it's an added field.
      $info = field_info_field($key);

      if ($info['type'] == 'image' && $image_info) {
        // This field contains an image
        // check for an apostrophe to see if multiple images.
        $filenames = array($field);
        if (strpos($field, ',')) {
          $filenames = explode(',', $field);
        }
        // Reset all the images to only use the ones provided.
        $product->{$key}[$language] = array();
        foreach ($filenames as $filename) {
          if ($filename == "") {
            // No image entered.
          }
          elseif (pathinfo($filename, PATHINFO_EXTENSION) == "") {
            commerce_xls_import_set_error($row, $key, "Image is missing extension");
          }
          else {
            $file = file_load($image_info[trim($filename)]);

            if ($file !== FALSE) {
              $product->{$key}[$language][] = get_object_vars($file);
              file_usage_add($file, 'commerce_xls_import', 'user', 1);
            }
            else {
              commerce_xls_import_set_error($row, $key, "Invalid image data entered");
            }
          }
        }
      }
      elseif ($info['type'] == 'entity_reference') {
        // Get nid from given entity name.
        if ($field != "") {
          // Break them up since multiples are comma delimited.
          $entity_references = explode(',', $field);

          // Reset the references to avoid adding duplicates.
          $product->{$key} = NULL;

          foreach ($entity_references as $entity_reference) {
            $nid = commerce_xls_import_get_entity_reference_nid(trim($entity_reference));

            if ($nid) {
              $product->{$key}[$language][]['target_id'] = $nid;
            }
          }
        }
      }
      elseif ($info['type'] == 'commerce_price') {
        if ($field != "") {
          $price = array(
            "$language" => array(
              0 => array(
                'amount' => $field * 100,
                'currency_code' => $values['currency_code'],
              ),
            ),
          );
          $product->{$key} = $price;
        }
      }
      elseif ($info['type'] == 'list_boolean') {
        $product->$key = array(
          "$language" => array(
            0 => array(
              'value' => $field,
            ),
          ),
        );
      }
      elseif ($info['type'] == 'taxonomy_term_reference') {
        $terms = commerce_xls_import_get_category_id($field);
        $product->$key = array(
          "$language" => $terms,
        );
      }
      else {
        $product->$key = array(
          "$language" => array(
            0 => array(
              'value' => $field,
            ),
          ),
        );
      }
    }
  }
  if (!$a_node) {
    // Set the price and currency.
    if (commerce_xls_import_validate_price($values)) {
      $price = array(
        "$language" => array(
          0 => array(
            'amount' => $values['commerce_price'] * 100,
            'currency_code' => $values['currency_code'],
          ),
        ),
      );
      $product->commerce_price = $price;
    }
  }
}

/**
 * Validates that the products price.
 *
 * @param array $values
 *    An array containing the product values.
 *
 * @return bool
 *    False if no price entered or invalid price entered. Otherwise true.
 */
function commerce_xls_import_validate_price($row, array $values) {
  if (!isset($values['commerce_price']) || $values['commerce_price'] == NULL) {
    commerce_xls_import_set_error($row, 'commerce_price', "No Price Entered!");
    return FALSE;
  }

  if (!is_numeric($values['commerce_price'])) {
    commerce_xls_import_set_error($row, 'commerce_price', "Invalid Price Entered!");
    return FALSE;
  }

  return TRUE;
}

/**
 * Gets the entity reference nid.
 */
function commerce_xls_import_get_entity_reference_nid($field) {
  $result = db_select('node', 'n')
    ->fields('n', array("nid"))
    ->condition('title', $field, 'like')
    ->execute();

  $data = $result->fetchAssoc();

  return $data['nid'];
}

/**
 * Implements hook_phpexcel_export().
 */
function commerce_xls_import_phpexcel_export($op, &$data, &$phpexcel, $options, $column = NULL, $row = NULL) {

  switch ($op) {
    case 'headers':
      break;

    case 'new sheet':
      $phpexcel->getActiveSheet()->getProtection()->setSheet(FALSE);
      $phpexcel->getActiveSheet()->getProtection()->setSort(FALSE);

      break;

    case 'data':
      break;

    case 'pre cell':
      break;

    case 'post cell':
      $style_array = array();
      if ($row > 1) {
        $error_status = commerce_xls_import_get_column_status($column, $row);

        if ($error_status == COMMERCE_XLS_IMPORT_DATA_ERROR) {
          $style_array = array(
            'fill' => array(
              'type' => PHPExcel_Style_Fill::FILL_SOLID,
              'startcolor' => array('argb' => '00FF9999'),
            ),
            'borders' => array(
              'allborders' => array(
                'style' => PHPExcel_Style_Border::BORDER_THIN,
                'color' => array('argb' => '00DA4141'),
              ),
            ),
          );
        }
        elseif ($error_status == COMMERCE_XLS_IMPORT_DATA_WARNING) {
          $style_array = array(
            'fill' => array(
              'type' => PHPExcel_Style_Fill::FILL_SOLID,
              'startcolor' => array('argb' => '00ffeb9c'),
            ),
            'borders' => array(
              'allborders' => array(
                'style' => PHPExcel_Style_Border::BORDER_THIN,
                'color' => array('argb' => '00EBEB51'),
              ),
            ),
          );
        }
        elseif ($error_status == COMMERCE_XLS_IMPORT_DATA_SUCCESS) {
          $style_array = array(
            'fill' => array(
              'type' => PHPExcel_Style_Fill::FILL_SOLID,
              'startcolor' => array('argb' => '0078FAA3'),
            ),
            'borders' => array(
              'allborders' => array(
                'style' => PHPExcel_Style_Border::BORDER_THIN,
                'color' => array('argb' => '0000994C'),
              ),
            ),
          );
        }

        if ($GLOBALS['nid_column'] != $column) {
          $phpexcel->getStyleByColumnAndRow($column, $row)->getProtection()->setLocked(PHPExcel_Style_Protection::PROTECTION_UNPROTECTED);
        }
        else {
          $phpexcel->getStyleByColumnAndRow($column, $row)->getProtection()->setLocked(PHPExcel_Style_Protection::PROTECTION_PROTECTED);
        }

        $phpexcel->getStyleByColumnAndRow($column, $row)->applyFromArray($style_array);

      }
      else {
        // Header row - mark for variation or parent.
        $owner = commerce_xls_import_get_field_owner($data);

        // Mark nid row for locking.
        if ($data == 'nid') {
          $GLOBALS['nid_column'] = $column;
        }

        if ($owner == 'variation') {
          $style_array = array(
            'fill' => array(
              'type' => PHPExcel_Style_Fill::FILL_SOLID,
              'startcolor' => array('argb' => '00fac090'),
            ),
            'borders' => array(
              'allborders' => array(
                'style' => PHPExcel_Style_Border::BORDER_THIN,
                'color' => array('argb' => '00fac090'),
              ),
            ),
          );
        }
        elseif ($owner == 'parent') {
          $style_array = array(
            'fill' => array(
              'type' => PHPExcel_Style_Fill::FILL_SOLID,
              'startcolor' => array('argb' => '008db4e3'),
            ),
            'borders' => array(
              'allborders' => array(
                'style' => PHPExcel_Style_Border::BORDER_THIN,
                'color' => array('argb' => '008db4e3'),
              ),
            ),
          );
        }
        elseif ($owner == 'both') {
          $style_array = array(
            'fill' => array(
              'type' => PHPExcel_Style_Fill::FILL_SOLID,
              'startcolor' => array('argb' => '0024ABB7'),
            ),
            'borders' => array(
              'allborders' => array(
                'style' => PHPExcel_Style_Border::BORDER_THIN,
                'color' => array('argb' => '0024ABB7'),
              ),
            ),
          );
        }
        $phpexcel->getStyleByColumnAndRow($column, $row)->getProtection()->setLocked(PHPExcel_Style_Protection::PROTECTION_PROTECTED);
        $phpexcel->getStyleByColumnAndRow($column, $row)->applyFromArray($style_array);
      }
      break;
  }
}

/**
 * Handles the main zip extraction.
 */
function commerce_xls_import_extract_zip() {
  $dir = realpath(".") . "/" . variable_get('file_public_path', conf_path() . '/files');

  $import_successful = commerce_xls_import_unpack_zip($dir, 'import_images/product_images', "$dir");

  // Add new files to the file table.
  if ($import_successful) {
    return commerce_xls_import_create_image_database_entries("public://");
  }
  else {
    return FALSE;
  }
}

/**
 * Adds the any images in the base path directory to the file table.
 *
 * @param string $base_path
 *   The base path where the file is located.
 *
 * @return array
 *   An array containing the filename and fid pairs.
 */
function commerce_xls_import_create_image_database_entries($base_path) {
  global $user;
  $results = array();

  $filenames = scandir($base_path);

  foreach ($filenames as $filename) {
    // Check file table for entry for this file, if an entry, ignore.
    if ($filename != "." && $filename != ".." && !is_dir("$base_path/$filename")) {
      $uri = "$base_path/$filename";
      if ($fid = commerce_xls_import_file_entry_exists($uri)) {
        // File entry exists update it.
        $results[$filename] = $fid;
      }
      else {
        // doesn't exist, create file entry.
        $file = new stdClass();
        $file->uid = $user->uid;
        $file->filename = $filename;
        $file->uri = $uri;
        $file->filemime = mime_content_type($uri);
        $file->filesize = filesize($uri);
        $file->status = 1;

        $file = file_save($file);
        $results[$filename] = $file->fid;
      }
    }
  }

  return $results;
}

/**
 * Checks to see if file entry already exists.
 */
function commerce_xls_import_file_entry_exists($uri) {
  $result = db_select('file_managed', 'f')
    ->fields('f', array('uri', 'fid'))
    ->condition('f.uri', $uri, '=')
    ->execute();

  while ($record = $result->fetchAssoc()) {
    return $record['fid'];
  }
  return FALSE;
}

/**
 * Base function for unpacking a zip.
 *
 * Uses the command line to unpack .zip files and move to public files
 * directory.
 */
function commerce_xls_import_unpack_zip($zip_dir, $filename, $save_dir) {
  $file_directory = $save_dir;
  $command = "unzip -oq $zip_dir/$filename.zip -d $file_directory 2>&1";
  $output = array();
  exec($command, $output, $result);
  $error_message = implode("\r\n", $output);

  if ($result != 0) {
    drupal_set_message(t("There was an error extracting @filename.zip. Please try again, if the problem persists contact the system administrator", array("@filename" => $filename)), "error");
    watchdog('commerce_xls_import', "Error: " . $error_message);
    return FALSE;
  }
  else {
    drupal_set_message(t("@filename.zip extracted successfully to @save_dir", array("!filename" => $filename, "@save_dir" => $save_dir)));
    return TRUE;
  }
}

/**
 * Gets any fields that may apply to the product.
 */
function commerce_xls_import_get_possible_fields($product_type) {
  $result = array();
  $fields = field_info_field_map();
  foreach ($fields as $key => $field) {

    if ((isset($field['bundles']['commerce_product']) && in_array($product_type, $field['bundles']['commerce_product']))
      || (isset($field['bundles']['node']) && in_array($product_type, $field['bundles']['node']))
    ) {
      // We don't want to include the product reference since the import will
      // take care of that for us.
      // Also don't want to include the field rating since it's based off user
      // comments and isn't something that can be set by a simple value.
      if ($key != 'field_product' && $key != 'field_rating' && $key != 'title_field') {
        $result[$key] = $key;
      }
    }
  }
  return $result;
}

/**
 * Get the headers needed for the export and import template.
 */
function commerce_xls_import_generate_headers($nid = NULL, $product_type = NULL) {
  $headers = array();

  $product = commerce_xls_import_get_possible_fields($product_type);

  $headers['Products'][] = "title";
  $headers['Products'][] = "variation_title";
  $headers['Products'][] = "sku";
  $headers['Products'] = array_merge($headers['Products'], array_keys($product));
  $headers['Products'][] = "status";
  $headers['Products'][] = "language";
  if ($nid != NULL) {
    $headers['Products'][] = "nid";
  }

  return $headers;
}

/**
 * Gets the owner of the form field.
 */
function commerce_xls_import_get_field_owner($field_name) {
  if ($field_name == 'title') {
    return 'parent';
  }
  elseif ($field_name == 'variation_title') {
    return 'variation';
  }
  elseif ($field_name == 'sku') {
    return 'variation';
  }
  elseif ($field_name == 'status') {
    return 'both';
  }
  elseif ($field_name == 'language') {
    return 'parent';
  }
  else {
    $field_info = field_info_field($field_name);
    if (isset($field_info['bundles']['commerce_product'])) {
      if (isset($field_info['bundles']['node'])) {
        return 'both';
      }
      else {
        return 'variation';
      }
    }
    else {
      return 'parent';
    }
  }
}

/**
 * Checks the status of the current import.
 */
function commerce_xls_import_current_status() {
  $current = variable_get('commerce_xls_import_import_count_status', '');

  $is_running = commerce_xls_import_is_running();

  if (($current == '' && $is_running)) {
    $message = t('Creating result document');
    $status = 0;
  }
  elseif ($current == '' && !$is_running) {
    $message = t('Import Complete');
    $status = 1;
    variable_set('import_completed', 1);
  }
  else {
    $message = t("Import status : !current/!total products evaluated", array("!current" => $current['completed'], "!total" => $current['total']));
    $status = 0;
  }

  if ($current == '') {
    $output = array(
      'completed' => 0,
      'total' => 0,
      'message' => $message,
      'status' => $status,
    );
  }
  else {
    $output = array(
      'completed' => $current['completed'],
      'total' => $current['total'],
      'message' => $message,
      'status' => $status,
    );
  }

  drupal_json_output($output);
}
